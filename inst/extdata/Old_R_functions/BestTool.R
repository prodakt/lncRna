#' Calculate Performance Statistics for Individual Tools
#'
#' Computes confusion matrix statistics (accuracy, precision, recall, etc.)
#' for selected coding potential prediction tools using results prepared by
#' `sumSingleTools`. Allows interactive selection in interactive sessions.
#'
#' @param sumSingleToolsList A list generated by `sumSingleTools()`, containing
#'   `$tools` (list of 0/1 prediction vectors), and `$isNC` (numeric vector of
#'   true labels: 1=nc, 0=cds).
#' @param tools An optional character vector specifying the names of the tools
#'   (from `names(sumSingleToolsList$tools)`) to analyze. If `NULL` (default)
#'   and the session is interactive, the user will be prompted to select tools.
#'   In a non-interactive session, `NULL` results in analyzing all tools.
#' @param digits The number of decimal places to round the final statistics to
#'   (default: 4).
#'
#' @return A data frame where rows are performance metrics and columns correspond
#'   to the selected tools, rounded. Returns `NULL` if validation fails, no
#'   tools are selected, or no statistics can be calculated.
#' @keywords confusion matrix accuracy performance caret lncRNA validation
#'   statistics
#' @export
#' @importFrom caret confusionMatrix
#' @examples
#' # Assume helper functions are loaded: validateInputList,
#' # selectToolsInteractively, validateToolNames, calculateSingleToolStats
#'
#' if (requireNamespace("caret", quietly = TRUE) &&
#'     exists("validateInputList") && exists("selectToolsInteractively") &&
#'     exists("validateToolNames") && exists("calculateSingleToolStats")) {
#'
#'   # --- Create Example Data (mimicking sumSingleTools output) ---
#'   set.seed(123) # for reproducibility
#'   nSeq <- 50
#'   exampleSummaryList <- list(
#'     seqIDs = paste0("Seq", seq_len(nSeq)),
#'     tools = list(
#'       CPC2 = sample(c(0, 1), nSeq, replace = TRUE, prob = c(0.3, 0.7)),
#'       CPAT = sample(c(0, 1), nSeq, replace = TRUE, prob = c(0.4, 0.6)),
#'       PLEK = sample(c(0, 1), nSeq, replace = TRUE, prob = c(0.5, 0.5)),
#'       FEELnc = rep(1, nSeq)
#'     ),
#'     type = sample(c("nc", "cds"), nSeq, replace = TRUE),
#'     isNC = NULL
#'   )
#'   exampleSummaryList$isNC <- ifelse(exampleSummaryList$type == "nc", 1, 0)
#'
#'   # --- Example 1: Analyze specific tools (non-interactive) ---
#'   selectedToolNames <- c("CPC2", "CPAT", "FEELnc")
#'   performanceStatsSpecific <- bestTool(
#'     sumSingleToolsList = exampleSummaryList,
#'     tools = selectedToolNames
#'   )
#'   print("Performance for CPC2, CPAT, FEELnc:")
#'   print(performanceStatsSpecific)
#'
#'   # --- Example 2: Demonstrate interactive use ---
#'   # This block will only run if the session is interactive.
#'   if (interactive()) {
#'     message("\nRunning in interactive mode. You will be prompted for selection.")
#'     performanceStatsInteractive <- bestTool(sumSingleToolsList = exampleSummaryList)
#'     print(performanceStatsInteractive)
#'   }
#' } else {
#'   message("Please install 'caret' and ensure helper functions are loaded.")
#' }
#'
bestTool <- function(sumSingleToolsList, tools = NULL, digits = 4) {

  # --- 1. Input Validation ---
  requiredElements <- c("tools", "isNC")
  if (!validateInputList(sumSingleToolsList, requiredElements)) {
    return(NULL)
  }

  if (length(unique(sumSingleToolsList$isNC)) < 2) {
    warning("Reference labels ('isNC') must contain at least two classes.", call. = FALSE)
    return(NULL)
  }
  if (!requireNamespace("caret", quietly = TRUE)) {
    warning("Package 'caret' is required. Please install it.", call. = FALSE)
    return(NULL)
  }

  availableTools <- names(sumSingleToolsList$tools)
  if (is.null(availableTools) || length(availableTools) == 0) {
    warning("No tool predictions found or names missing in sumSingleToolsList$tools.", call. = FALSE)
    return(NULL)
  }

  # --- 2. Tool Selection ---
  if (is.null(tools)) {
    # This helper function must be designed to return all tools in a
    # non-interactive session.
    selectedTools <- selectToolsInteractively(availableTools)
  } else {
    selectedTools <- validateToolNames(tools, availableTools)
  }

  if (is.null(selectedTools) || length(selectedTools) == 0) {
    warning("No valid tools selected or available for analysis. Returning NULL.", call. = FALSE)
    return(NULL)
  }

  # --- 3. Calculate Statistics for Selected Tools ---
  resultsList <- list()
  referenceLabels <- sumSingleToolsList$isNC
  refFactor <- factor(referenceLabels, levels = c("0", "1"))
  nSeqs <- length(refFactor)

  for (toolName in selectedTools) {
    toolPredictions <- sumSingleToolsList$tools[[toolName]]

    if (length(toolPredictions) != nSeqs) {
      warning(
        paste0(
          "Length mismatch for '", toolName, "'. Expected ", nSeqs,
          " but got ", length(toolPredictions), ". Skipping."
        ),
        call. = FALSE
      )
      next
    }

    singleToolStatsVector <- calculateSingleToolStats(toolName, toolPredictions, refFactor)

    if (!is.null(singleToolStatsVector)) {
      resultsList[[toolName]] <- singleToolStatsVector
    }
  }

  # --- 4. Format Output ---
  if (length(resultsList) == 0) {
    warning("No statistics could be calculated for the selected tools.", call. = FALSE)
    return(NULL)
  }

  allMetricNames <- unique(unlist(lapply(resultsList, names)))
  if (is.null(allMetricNames)) {
    warning("Could not determine metric names from results. Returning NULL.", call. = FALSE)
    return(NULL)
  }

  alignedResultsList <- lapply(resultsList, function(toolStatsVector) {
    template <- rep(NA_real_, length(allMetricNames))
    names(template) <- allMetricNames
    commonMetrics <- intersect(names(toolStatsVector), allMetricNames)
    if (length(commonMetrics) > 0) {
      template[commonMetrics] <- toolStatsVector[commonMetrics]
    }
    template
  })

  finalResultsDf <- as.data.frame(do.call(cbind, alignedResultsList), check.names = FALSE)

  finalResultsDf <- as.data.frame(
    lapply(finalResultsDf, function(col) {
      if (is.numeric(col)) round(col, digits = digits) else col
    }),
    check.names = FALSE,
    row.names = allMetricNames
  )

  return(finalResultsDf)
}
