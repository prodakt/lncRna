#' Calculate Performance Statistics for "At Least N Tools" Predictions
#'
#' Computes confusion matrix statistics (accuracy, precision, recall, etc.) for
#' each "at least n tools" prediction vector generated by `sumAtLeast`.
#' Requires the 'caret' package.
#'
#' @param sumAtLeastList A list generated by `sumAtLeast()`, containing at least
#'   `$isNC` (numeric vector of true labels: 1=nc, 0=cds) and `$atLeastN`
#'   (a list of 0/1 prediction vectors named `atl1`, `atl2`, ...).
#' @param digits The number of decimal places to round the final statistics to
#'   (default: 4).
#'
#' @return A data frame where rows are performance metrics and columns correspond
#'   to the "at least n" (`atl1`, `atl2`, ...) predictions. Returns `NULL` if
#'   validation fails or no statistics can be calculated.
#' @keywords confusion matrix accuracy performance caret lncRNA validation
#'   consensus statistics
#' @export
#' @importFrom caret confusionMatrix
#' @examples
#' # Assume helper functions 'validateInputList' and 'calculateSingleToolStats'
#' # are available in the package.
#'
#' if (requireNamespace("caret", quietly = TRUE) &&
#'     exists("validateInputList") && exists("calculateSingleToolStats")) {
#'
#'   # --- Create Example Data (mimicking sumAtLeast output) ---
#'   set.seed(789) # for reproducibility
#'   nSeqExample <- 75
#'   exampleAtLeastList <- list(
#'     seqIDs = paste0("Seq", seq_len(nSeqExample)),
#'     isNC = sample(c(0, 1), nSeqExample, replace = TRUE, prob = c(0.55, 0.45)),
#'     type = ifelse(sample(c(0, 1), nSeqExample, replace = TRUE) == 1, "nc", "cds"),
#'     selected_tools_predictions = list(
#'        ToolX = sample(c(0,1), nSeqExample, replace=TRUE),
#'        ToolY = sample(c(0,1), nSeqExample, replace=TRUE)
#'     ),
#'     sums_selected_tools = sample(0:2, nSeqExample, replace=TRUE),
#'     atLeastN = list(
#'       atl1 = ifelse(sample(0:2, nSeqExample, replace=TRUE) >= 1, 1, 0),
#'       atl2 = ifelse(sample(0:2, nSeqExample, replace=TRUE) >= 2, 1, 0)
#'     )
#'   )
#'
#'   # --- Run bestToolAtLeast ---
#'   performanceAtLeast <- bestToolAtLeast(
#'     sumAtLeastList = exampleAtLeastList
#'   )
#'
#'   print("Performance for 'at least n' predictions:")
#'   print(performanceAtLeast)
#'
#' } else {
#'   message("Please install 'caret' and ensure helper functions are loaded.")
#' }
#'
bestToolAtLeast <- function(sumAtLeastList, digits = 4) {

  # --- 1. Input Validation ---
  requiredElements <- c("isNC", "atLeastN")
  if (!validateInputList(sumAtLeastList, requiredElements)) {
    return(NULL)
  }

  if (!is.list(sumAtLeastList$atLeastN) || length(sumAtLeastList$atLeastN) == 0) {
    warning("Input list '$atLeastN' must be a non-empty list.", call. = FALSE)
    return(NULL)
  }
  if (length(unique(sumAtLeastList$isNC)) < 2) {
    warning("Reference labels ('isNC') must contain at least two classes.", call. = FALSE)
    return(NULL)
  }
  if (!requireNamespace("caret", quietly = TRUE)) {
    warning("Package 'caret' is required. Please install it.", call. = FALSE)
    return(NULL)
  }

  # --- 2. Calculate Statistics for each 'atl{n}' vector ---
  resultsList <- list()
  referenceLabels <- sumAtLeastList$isNC
  atLeastNPredictions <- sumAtLeastList$atLeastN
  refFactor <- factor(referenceLabels, levels = c("0", "1"))
  nSeqs <- length(refFactor)

  for (atlName in names(atLeastNPredictions)) {
    predictionsVector <- atLeastNPredictions[[atlName]]

    if (length(predictionsVector) != nSeqs) {
      warning(
        paste0(
          "Length mismatch for '", atlName, "'. Expected ", nSeqs,
          " but got ", length(predictionsVector), ". Skipping."
        ),
        call. = FALSE
      )
      next
    }

    singleResultVector <- calculateSingleToolStats(
      toolName = atlName,
      predictions = predictionsVector,
      referenceFactor = refFactor
    )

    if (!is.null(singleResultVector)) {
      resultsList[[atlName]] <- singleResultVector
    }
  }

  # --- 3. Format Output ---
  if (length(resultsList) == 0) {
    warning("No statistics could be calculated for any 'atLeastN' predictions.", call. = FALSE)
    return(NULL)
  }

  allMetricNames <- unique(unlist(lapply(resultsList, names)))
  if (is.null(allMetricNames)) {
    warning("Could not determine metric names from results. Returning NULL.", call. = FALSE)
    return(NULL)
  }

  alignedResultsList <- lapply(resultsList, function(atlStatsVector) {
    template <- rep(NA_real_, length(allMetricNames))
    names(template) <- allMetricNames
    commonMetrics <- intersect(names(atlStatsVector), allMetricNames)
    if (length(commonMetrics) > 0) {
      template[commonMetrics] <- atlStatsVector[commonMetrics]
    }
    template # Return a named vector
  })

  finalResultsDf <- as.data.frame(do.call(cbind, alignedResultsList), check.names = FALSE)

  finalResultsDf <- as.data.frame(
    lapply(finalResultsDf, function(col) {
      if (is.numeric(col)) round(col, digits = digits) else col
    }),
    check.names = FALSE,
    row.names = allMetricNames
  )

  return(finalResultsDf)
}
