#' Summarize Agreement Among Selected Coding Potential Tools
#'
#' Calculates indicators for sequences predicted as non-coding by at least 'n'
#' selected tools. Also includes the sum of positive predictions.
#'
#' @param sumSingleToolsList A list generated by a precursor function, containing
#'   at least `$seqIDs` and `$tools` (a named list of 0/1 prediction vectors).
#' @param tools An optional character vector of tool names to analyze. If `NULL`
#'   (default) and the session is interactive, the user is prompted to select
#'   tools. In a non-interactive session, `NULL` results in all tools being used.
#'
#' @return A list containing:
#'   \item{seqIDs}{Original sequence identifiers.}
#'   \item{isNC}{Original numeric indicator (if present).}
#'   \item{type}{Original type annotation (if present).}
#'   \item{selectedToolsPredictions}{A sublist of prediction vectors for the
#'     selected tools.}
#'   \item{sumsSelectedTools}{A numeric vector with the count of selected tools
#'     predicting non-coding for each sequence.}
#'   \item{atLeastN}{A list where each element `atl{n}` is a numeric vector
#'     (0/1) indicating prediction by at least `n` tools.}
#'   Returns `NULL` if validation fails or no tools are selected.
#' @keywords summary agreement coding potential lncRNA consensus
#' @export
#' @examples
#' # --- 1. Create Example Data ---
#' set.seed(456)
#' nSeqExample <- 60
#' exampleInputList <- list(
#'   seqIDs = paste0("ID", seq_len(nSeqExample)),
#'   tools = list(
#'     ToolA = sample(c(0, 1), nSeqExample, replace = TRUE, prob = c(0.6, 0.4)),
#'     ToolB = sample(c(0, 1), nSeqExample, replace = TRUE, prob = c(0.4, 0.6)),
#'     ToolC = sample(c(0, 1), nSeqExample, replace = TRUE, prob = c(0.7, 0.3))
#'   ),
#'   type = sample(c("nc", "cds"), nSeqExample, replace = TRUE)
#' )
#' exampleInputList$isNC <- ifelse(exampleInputList$type == "nc", 1, 0)
#'
#' # --- 2. Run Non-interactive Examples ---
#'
#' # Example 2a: Analyze specific tools
#' selectedToolNames <- c("ToolA", "ToolB")
#' resultsSpecific <- sumAtLeast(
#'   sumSingleToolsList = exampleInputList,
#'   tools = selectedToolNames
#' )
#' if (!is.null(resultsSpecific)) {
#'   print("Results for ToolA and ToolB:")
#'   print(head(resultsSpecific$sumsSelectedTools))
#'   print(head(resultsSpecific$atLeastN$atl2))
#' }
#'
#' # Example 2b: Analyze all tools (by passing tools = NULL)
#' resultsAll <- sumAtLeast(sumSingleToolsList = exampleInputList)
#' if (!is.null(resultsAll)) {
#'   print("Results for all tools:")
#'   print(head(resultsAll$sumsSelectedTools))
#'   print(head(resultsAll$atLeastN$atl3))
#' }
#'
#' # --- 3. Interactive Example ---
#' # This block will only run if the session is interactive.
#' if (interactive()) {
#'   message("Running interactive example. You will be prompted for selection.")
#'   resultsInteractive <- sumAtLeast(sumSingleToolsList = exampleInputList)
#' }
sumAtLeast <- function(sumSingleToolsList, tools = NULL) {

  # --- 1. Input Validation ---
  requiredElements <- c("seqIDs", "tools")
  # Assuming validateInputList is a helper function in your package
  if (!validateInputList(sumSingleToolsList, requiredElements)) {
    return(NULL)
  }

  availableTools <- names(sumSingleToolsList$tools)
  if (is.null(availableTools) || length(availableTools) == 0) {
    warning("No tool predictions found in 'sumSingleToolsList$tools'.", call. = FALSE)
    return(NULL)
  }

  # --- 2. Tool Selection (with interactive fallback) ---
  if (is.null(tools)) {
    # selectToolsInteractively should return all tools if non-interactive
    selectedTools <- selectToolsInteractively(availableTools)
  } else {
    # validateToolNames should handle missing tools gracefully
    selectedTools <- validateToolNames(tools, availableTools)
  }

  if (is.null(selectedTools) || length(selectedTools) == 0) {
    warning("No valid tools selected for analysis.", call. = FALSE)
    return(NULL)
  }

  # --- 3. Core Calculation ---
  selectedPredictionsList <- sumSingleToolsList$tools[selectedTools]
  nSeqs <- length(sumSingleToolsList$seqIDs)

  # Verify that all selected prediction vectors have the correct length
  if (!all(sapply(selectedPredictionsList, length) == nSeqs)) {
    warning("One or more selected tools have a prediction vector of incorrect length.", call. = FALSE)
    return(NULL)
  }

  # Combine selected predictions into a matrix and calculate sums
  # This handles the case of 1 or more tools correctly
  predictionsMatrix <- do.call(cbind, selectedPredictionsList)
  sumsSelected <- rowSums(predictionsMatrix)

  # Calculate "at least n" indicators
  atLeastNResults <- list()
  nToolsSelected <- length(selectedTools)
  if (nToolsSelected > 0) {
    for (n in seq_len(nToolsSelected)) {
      atLeastNResults[[paste0('atl', n)]] <- ifelse(sumsSelected >= n, 1, 0)
    }
  }

  # --- 4. Assemble Output List ---
  finalList <- list(
    seqIDs = sumSingleToolsList$seqIDs,
    isNC = sumSingleToolsList$isNC, # Carry over optional elements
    type = sumSingleToolsList$type, # Carry over optional elements
    selectedToolsPredictions = selectedPredictionsList,
    sumsSelectedTools = sumsSelected,
    atLeastN = atLeastNResults
  )

  return(finalList)
}
