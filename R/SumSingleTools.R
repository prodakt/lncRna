#' Summarize Coding Potential Results for Test Sets (List Output)
#'
#' This function takes the output from `CodPot2tbl` and test set IDs
#' to create a summary list, annotating sequences as non-coding (nc) or
#' protein-coding (cds) based on the test sets and calculating the sum of
#' non-coding predictions across tools. It filters the results to include
#' only sequences present in the provided test sets.
#'
#' @param CodPot_list A list object generated by `CodPot2tbl()`. Must contain
#'                    `$seqIDs` (character vector) and `$tools` (a list of
#'                    numeric vectors (0/1)).
#' @param nc_test A character vector of sequence IDs known to be non-coding,
#'                used for testing/validation.
#' @param cds_test A character vector of sequence IDs known to be protein-coding,
#'                 used for testing/validation.
#'
#' @return A list containing elements aligned by index, including only sequences
#'         present in `nc_test` or `cds_test`:
#'         \item{seqIDs}{Filtered character vector of sequence identifiers.}
#'         \item{tools}{Filtered list where each element corresponds to a tool
#'                      and contains a numeric vector (0/1) for the filtered sequences.}
#'         \item{type}{Filtered character vector with annotation ("nc" or "cds").}
#'         \item{isNC}{Filtered numeric vector: 1 if type is "nc", 0 if type is "cds".}
#'         \item{sums}{Filtered numeric vector with the row sum of predictions
#'                     across all included tools for each sequence.}
#' @keywords summary validation lncRNA cds bioinformatics list filter
#' @export
#' @examples
#' # Assume CodPot_results is output from CodPot2tbl()
#' # Assume nc_tt and cds_tt are outputs from test.train.nc() and test.train.cds()
#' # Example:
#' # summary_list <- SumSingleTools(CodPot_list = CodPot_results,
#' #                                nc_test = nc_tt$nc.test,
#' #                                cds_test = cds_tt$cds.test)
#' # print(summary_list$seqIDs[1:5])
#' # print(summary_list$tools$CPC2[1:5]) # Access tool predictions
#' # print(summary_list$type[1:5])
#' # print(summary_list$isNC[1:5])
#' # print(summary_list$sums[1:5])
#'
SumSingleTools <- function(CodPot_list, nc_test, cds_test) {
  # --- Input Validation ---
  if (!is.list(CodPot_list) || !("seqIDs" %in% names(CodPot_list)) || !("tools" %in% names(CodPot_list)) || !is.list(CodPot_list$tools)) {
    stop("Input 'CodPot_list' must be a list generated by CodPot2tbl() with 'seqIDs' and 'tools' elements.")
  }
  if (!is.character(nc_test)) stop("'nc_test' must be a character vector.")
  if (!is.character(cds_test)) stop("'cds_test' must be a character vector.")

  original_seqIDs <- CodPot_list$seqIDs
  original_tools <- CodPot_list$tools

  if (length(original_seqIDs) == 0) {
    warning("Input 'CodPot_list' contains no sequence IDs.")
    # Return an empty list structure
    return(list(seqIDs = character(0),
                tools = list(),
                type = character(0),
                isNC = numeric(0),
                sums = numeric(0)))
  }

  # --- Identify Indices to Keep ---
  # Find indices corresponding to sequences present in either test set
  indices_to_keep <- which(original_seqIDs %in% c(nc_test, cds_test))

  if (length(indices_to_keep) == 0) {
    warning("None of the sequences in CodPot_list$seqIDs were found in nc_test or cds_test.")
    # Return an empty list structure
    return(list(seqIDs = character(0),
                tools = list(),
                type = character(0),
                isNC = numeric(0),
                sums = numeric(0)))
  }

  # --- Filter Data ---
  filtered_seqIDs <- original_seqIDs[indices_to_keep]
  filtered_tools <- list()
  if (length(original_tools) > 0) {
    for (tool_name in names(original_tools)) {
      # Ensure the tool vector has the same length as original_seqIDs before filtering
      if(length(original_tools[[tool_name]]) == length(original_seqIDs)){
        filtered_tools[[tool_name]] <- original_tools[[tool_name]][indices_to_keep]
      } else {
        warning(paste("Length mismatch for tool:", tool_name, ". Skipping this tool."))
        # Optionally, create a vector of NAs or handle differently
        # filtered_tools[[tool_name]] <- rep(NA, length(indices_to_keep))
      }
    }
  } else {
    warning("Input 'CodPot_list' contains no tool prediction data in '$tools'. 'sums' will be 0.")
  }


  # --- Create Annotations for Filtered Data ---
  n_filtered <- length(filtered_seqIDs)
  filtered_type <- character(n_filtered)
  filtered_isNC <- numeric(n_filtered)

  # Assign type and isNC based on the filtered IDs
  is_nc <- filtered_seqIDs %in% nc_test
  is_cds <- filtered_seqIDs %in% cds_test

  filtered_type[is_nc] <- "nc"
  filtered_type[is_cds] <- "cds" # This will overwrite if an ID is in both lists, cds takes precedence here. Adjust if needed.

  filtered_isNC[is_nc] <- 1
  filtered_isNC[is_cds] <- 0

  # --- Calculate Sums for Filtered Data ---
  filtered_sums <- numeric(n_filtered)
  if (length(filtered_tools) > 0) {
    # Combine the filtered tool vectors into a matrix to calculate row sums
    # Ensure all vectors in filtered_tools have the same length (n_filtered)
    if(all(sapply(filtered_tools, length) == n_filtered)) {
      filtered_tool_matrix <- do.call(cbind, filtered_tools)
      filtered_sums <- rowSums(filtered_tool_matrix)
    } else {
      warning("Could not calculate sums due to length inconsistencies in filtered tool data.")
      filtered_sums <- rep(NA, n_filtered) # Assign NA if sums cannot be calculated
    }
  } # Otherwise, sums remain 0 initialized earlier

  # --- Assemble the Final List ---
  result_list <- list(
    seqIDs = filtered_seqIDs,
    tools = filtered_tools,
    type = filtered_type,
    isNC = filtered_isNC,
    sums = filtered_sums
  )

  return(result_list)
}
