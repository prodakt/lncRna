#' Evaluate Performance of Tool Combinations
#'
#' Computes confusion matrix statistics for predictions generated by various
#' tool combinations, using the output from `evaluateToolCombinations`.
#'
#' @param combinationSummaryList A list generated by `evaluateToolCombinations()`,
#'   containing `$isNC` (true labels) and `$toolCombinations` (a list of
#'   prediction vectors for each combination).
#' @param combinations An optional character vector specifying the names of the
#'   tool combinations (e.g., "ToolA+ToolB") to analyze. If `NULL`, behavior
#'   depends on the session: interactive mode prompts for selection, while
#'   non-interactive mode analyzes all available combinations.
#' @param digits The number of decimal places to round final statistics to
#'   (default: 4).
#'
#' @return A data frame where rows are performance metrics and columns correspond
#'   to the analyzed tool combinations. Returns `NULL` on error or if no
#'   statistics can be calculated.
#' @export
#'
#' @examples
#' # --- 1. Create a mock object mimicking evaluateToolCombinations output ---
#' set.seed(202)
#' n_seq <- 80
#' exampleCombinationSummary <- list(
#'   isNC = sample(c(0, 1), n_seq, replace = TRUE),
#'   toolCombinations = list(
#'     `ToolA+ToolB` = sample(c(0, 1), n_seq, replace = TRUE, prob = c(0.7, 0.3)),
#'     `ToolA+ToolC` = sample(c(0, 1), n_seq, replace = TRUE, prob = c(0.6, 0.4)),
#'     `ToolB+ToolC` = sample(c(0, 1), n_seq, replace = TRUE, prob = c(0.5, 0.5))
#'   )
#'   # Other elements like seqIDs, type would also be present
#' )
#'
#' # --- 2. Run the function ---
#' # Example 1: Analyze specific combinations
#' perf_specific <- BestToolCombination(
#'   combinationSummaryList = exampleCombinationSummary,
#'   combinations = c("ToolA+ToolB", "ToolB+ToolC")
#' )
#' print("Performance for specific combinations:")
#' print(perf_specific)
#'
#' # Example 2: Analyze all combinations (non-interactively)
#' perf_all <- BestToolCombination(
#'   combinationSummaryList = exampleCombinationSummary
#' )
#' print("Performance for all combinations:")
#' print(perf_all)
#'
BestToolCombination <- function(combinationSummaryList, combinations = NULL,
                                digits = 4) {
    # --- 1. Input Validation ---
    stopifnot(
        "'combinationSummaryList' must be a list" = is.list(combinationSummaryList),
        "'combinationSummaryList' must contain 'isNC' and 'toolCombinations'" =
            all(c("isNC", "toolCombinations") %in% names(combinationSummaryList)),
        "'combinationSummaryList$toolCombinations' must be a list" = 
            is.list(combinationSummaryList$toolCombinations),
        "'combinationSummaryList$isNC' must be numeric" = 
            is.numeric(combinationSummaryList$isNC)
    )
    
    available_combinations <- names(combinationSummaryList$toolCombinations)
    if (length(available_combinations) == 0) {
        warning("No tool combinations found in '$toolCombinations'.", call. = FALSE)
        return(NULL)
    }
    
    reference_labels <- combinationSummaryList$isNC
    if (length(unique(reference_labels)) < 2) {
        warning("Reference labels ('isNC') must contain both classes (0 and 1).",
                call. = FALSE)
        return(NULL)
    }
    
    # --- 2. Combination Selection (reusing the central helper) ---
    # We trick the helper by passing combinations as if they were tools
    selected_combinations <- handleToolSelection(
        availableTools = available_combinations,
        selectedTools = combinations
    )
    
    if (length(selected_combinations) == 0) {
        return(NULL) # Helper already issued a warning
    }
    
    # --- 3. Calculate Statistics ---
    results_list <- lapply(selected_combinations, function(combo_name) {
        predictions_vector <- combinationSummaryList$toolCombinations[[combo_name]]
        
        if (length(predictions_vector) != length(reference_labels)) {
            warning("Length mismatch for combination '", combo_name, "'. Skipping.",
                    call. = FALSE)
            return(NULL)
        }
        
        # Use the central, reusable metrics calculation function
        calculateMetrics(predictions = predictions_vector, 
                         reference = reference_labels)
    })
    names(results_list) <- selected_combinations
    
    results_list <- Filter(Negate(is.null), results_list)
    
    if (length(results_list) == 0) {
        warning("No statistics could be calculated for selected combinations.",
                call. = FALSE)
        return(NULL)
    }
    
    # --- 4. Format Output ---
    final_df <- do.call(cbind, results_list)
    
    desired_order <- c("Accuracy", "Kappa", "AccuracyLower", "AccuracyUpper", 
                       "AccuracyNull", "AccuracyPValue", "McnemarPValue", 
                       "Sensitivity", "Specificity", "Pos Pred Value", 
                       "Neg Pred Value", "Precision", "Recall", "F1", 
                       "Prevalence", "Detection Rate", "Detection Prevalence", 
                       "Balanced Accuracy")
    final_df <- final_df[intersect(desired_order, rownames(final_df)), , drop = FALSE]
    
    final_df <- round(final_df, digits = digits)
    
    # Use check.names = FALSE to prevent R from changing '+' to '.'
    return(as.data.frame(final_df, check.names = FALSE))
}