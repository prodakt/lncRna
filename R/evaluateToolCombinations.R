#' Evaluate Performance of Tool Combinations
#'
#' Identifies sequences predicted as non-coding by specific combinations
#' (intersections) of tools. It generates prediction vectors for all
#' combinations of 2 or more selected tools.
#'
#' @param summaryList A list generated by `prepareEvaluationSets()`, containing
#'   `$seqIDs`, `$tools` (a list of 0/1 prediction vectors), `$isNC`, and `$type`.
#' @param tools An optional character vector specifying which tools to use for
#'   creating combinations. If `NULL`, the behavior depends on the session:
#'   interactive mode will prompt for selection, while non-interactive mode
#'   will use all available tools.
#'
#' @return A list containing:
#'   \item{seqIDs}{Original sequence identifiers from the input.}
#'   \item{isNC}{Original true labels (1=nc, 0=cds) from the input.}
#'   \item{type}{Original type annotation ('nc', 'cds') from the input.}
#'   \item{selectedToolsPredictions}{A list of prediction vectors for the tools
#'     selected for this analysis.}
#'   \item{toolCombinations}{A list where each element is named after a tool
#'     combination (e.g., "ToolA+ToolB") and contains a binary vector (0/1)
#'     indicating if a sequence was predicted as non-coding by ALL tools in that
#'     combination.}
#' @importFrom utils combn
#' @export
#'
#' @examples
#' # --- 1. Create a mock object mimicking the output of prepareEvaluationSets ---
#' set.seed(101)
#' n_seq <- 50
#' evaluationSummary <- list(
#'   seqIDs = paste0("Seq", 1:n_seq),
#'   tools = list(
#'     ToolX = sample(c(0, 1), n_seq, replace = TRUE),
#'     ToolY = sample(c(0, 1), n_seq, replace = TRUE),
#'     ToolZ = sample(c(0, 1), n_seq, replace = TRUE)
#'   ),
#'   type = sample(c("nc", "cds"), n_seq, replace = TRUE),
#'   isNC = sample(c(0, 1), n_seq, replace = TRUE)
#' )
#'
#' # --- 2. Run the function ---
#' # Example 1: Analyze combinations of specific tools
#' results_comb <- evaluateToolCombinations(
#'   summaryList = evaluationSummary,
#'   tools = c("ToolX", "ToolY", "ToolZ")
#' )
#'
#' if (!is.null(results_comb)) {
#'   print("Names of generated combinations:")
#'   print(names(results_comb$toolCombinations))
#'
#'   print("Head of 'ToolX+ToolY' combination results:")
#'   print(head(results_comb$toolCombinations[["ToolX+ToolY"]]))
#' }
#'
#' # Example 2: Non-interactively analyze all tools
#' results_all_comb <- evaluateToolCombinations(summaryList = evaluationSummary)
#'
evaluateToolCombinations <- function(summaryList, tools = NULL) {
    
    # --- 1. Input Validation ---
    stopifnot(
        "'summaryList' must be a list" = is.list(summaryList),
        "'summaryList' must contain required elements" =
            all(c("seqIDs", "tools", "isNC", "type") %in% names(summaryList))
    )
    
    available_tools <- names(summaryList$tools)
    if (length(available_tools) == 0) {
        warning("No tool predictions found in 'summaryList$tools'.", call. = FALSE)
        return(NULL)
    }
    
    # --- 2. Tool Selection ---
    selected_tools <- handleToolSelection(
        availableTools = available_tools,
        selectedTools = tools
    )
    
    if (length(selected_tools) < 2) {
        warning("At least two valid tools must be selected to form combinations.",
                call. = FALSE)
        return(NULL)
    }
    
    # --- 3. Prepare Data for Selected Tools ---
    selected_predictions_list <- summaryList$tools[selected_tools]
    predictions_matrix <- do.call(cbind, selected_predictions_list)
    
    n_seqs <- length(summaryList$seqIDs)
    if (nrow(predictions_matrix) != n_seqs) {
        warning("Dimension mismatch after combining tool predictions. Aborting.",
                call. = FALSE)
        return(NULL)
    }
    
    # --- 4. Generate Combinations and Calculate Intersections ---
    tool_combinations_results <- list()
    num_selected <- length(selected_tools)
    
    for (k in 2:num_selected) {
        tool_combinations <- utils::combn(selected_tools, k, simplify = FALSE)
        
        for (combo in tool_combinations) {
            combination_id <- paste(combo, collapse = "+")
            sub_matrix <- predictions_matrix[, combo, drop = FALSE]
            is_match <- rowSums(sub_matrix, na.rm = TRUE) == k
            
            tool_combinations_results[[combination_id]] <- as.integer(is_match)
        }
    }
    
    # --- 5. Assemble Output List ---
    final_list <- list(
        seqIDs = summaryList$seqIDs,
        isNC = summaryList$isNC,
        type = summaryList$type,
        selectedToolsPredictions = selected_predictions_list,
        toolCombinations = tool_combinations_results
    )
    
    return(final_list)
}