#' Summarize Predictions for Combinations of Tools
#'
#' Identifies sequences predicted as non-coding by specific combinations of
#' selected tools (i.e., the intersection of predictions for tools in a given combination).
#' It considers combinations of 2 or more tools.
#' Uses the list output from `SumSingleTools` and allows interactive tool selection.
#'
#' @param SumSingleTools_list A list generated by `SumSingleTools()`, containing at least
#'                            `$seqIDs`, `$tools` (list of 0/1 prediction vectors),
#'                            `$isNC`, and `$type`.
#' @param tools An optional character vector specifying the names of the tools
#'              (from `names(SumSingleTools_list$tools)`) to use for combinations.
#'              If `NULL` (default), the user will be prompted to select tools interactively.
#'
#' @return A list containing:
#'         \item{seqIDs}{Original sequence identifiers from the input list.}
#'         \item{isNC}{Original numeric indicator (1=nc, 0=cds) from the input list.}
#'         \item{type}{Original type annotation ('nc', 'cds') from the input list.}
#'         \item{selected_tools_predictions}{A sublist containing only the prediction
#'                                           vectors for the tools selected for this analysis.}
#'         \item{tool_combinations}{A list where each element is named after a tool
#'                                  combination (e.g., "ToolA+ToolB") and contains a
#'                                  binary vector (0/1) indicating if each sequence was
#'                                  predicted as non-coding by ALL tools in that combination.}
#'         Returns `NULL` if input validation fails, fewer than two tools are selected,
#'         or no combinations can be processed.
#' @keywords summary combination coding potential lncRNA validation intersection
#' @export
#' @importFrom utils combn
#' @examples
#'
#' # --- Create Example Data (mimicking SumSingleTools output) ---
#' if (exists(".validate_input_list") && exists(".select_tools_interactively") &&
#'     exists(".validate_tool_names")) {
#'
#'   set.seed(101) # for reproducibility
#'   n_seq_example <- 50
#'   example_input_list_comb <- list(
#'     seqIDs = paste0("Seq", 1:n_seq_example),
#'     tools = list(
#'       ToolX = sample(c(0, 1), n_seq_example, replace = TRUE, prob = c(0.5, 0.5)),
#'       ToolY = sample(c(0, 1), n_seq_example, replace = TRUE, prob = c(0.4, 0.6)),
#'       ToolZ = sample(c(0, 1), n_seq_example, replace = TRUE, prob = c(0.7, 0.3))
#'     ),
#'     type = sample(c("nc", "cds"), n_seq_example, replace = TRUE),
#'     isNC = NULL
#'   )
#'   example_input_list_comb$isNC <- ifelse(example_input_list_comb$type == "nc", 1, 0)
#'
#'   # --- Example 1: Analyze specific tools ---
#'   selected_tools_for_comb <- c("ToolX", "ToolY", "ToolZ")
#'   results_comb_specific <- SumCombTools(SumSingleTools_list = example_input_list_comb,
#'                                         tools = selected_tools_for_comb)
#'   if (!is.null(results_comb_specific)) {
#'     print("Results for specific tool combinations (ToolX, ToolY, ToolZ):")
#'     # Print structure or specific combination results
#'     # print(str(results_comb_specific$tool_combinations, max.level = 1))
#'     if("ToolX+ToolY" %in% names(results_comb_specific$tool_combinations)){
#'       print("ToolX+ToolY combination (first 5):")
#'       print(head(results_comb_specific$tool_combinations[["ToolX+ToolY"]], 5))
#'     }
#'      if("ToolX+ToolY+ToolZ" %in% names(results_comb_specific$tool_combinations)){
#'       print("ToolX+ToolY+ToolZ combination (first 5):")
#'       print(head(results_comb_specific$tool_combinations[["ToolX+ToolY+ToolZ"]], 5))
#'     }
#'   }
#'
#'   # --- Example 2: Simulate non-interactive selection (selects first tool) ---
#'   # Note: SumCombTools requires at least 2 tools to form combinations.
#'   # The .select_tools_interactively helper in non-interactive mode might return only one.
#'   # For a meaningful non-interactive example, ensure enough tools are "selected".
#'   # Here, we'll pass two tools to simulate a valid non-interactive case.
#'   cat("\nSimulating non-interactive run with two tools (ToolX, ToolY):\n")
#'   results_comb_noninteractive <- SumCombTools(SumSingleTools_list = example_input_list_comb,
#'                                               tools = c("ToolX", "ToolY"))
#'   if (!is.null(results_comb_noninteractive) &&
#'       "ToolX+ToolY" %in% names(results_comb_noninteractive$tool_combinations)) {
#'     print("ToolX+ToolY combination (first 5):")
#'     print(head(results_comb_noninteractive$tool_combinations[["ToolX+ToolY"]], 5))
#'   }
#' } else {
#'   message("Please ensure helper functions are loaded to run SumCombTools examples.")
#' }
#'
SumCombTools <- function(SumSingleTools_list, tools = NULL) {

  # --- 1. Input Validation ---
  required_elements <- c("seqIDs", "selected_tools_predictions", "isNC", "type")
  if (!.validate_input_list(SumSingleTools_list, required_elements)) {
    return(NULL)
  }

  available_tools <- names(SumSingleTools_list$tools)
  if (is.null(available_tools) && length(SumSingleTools_list$tools) > 0) {
    warning("Tool names are missing from SumSingleTools_list$tools.", call. = FALSE)
    return(NULL)
  }

  # --- 2. Tool Selection ---
  if (is.null(tools)) {
    selected_tool_names <- .select_tools_interactively(available_tools)
  } else {
    selected_tool_names <- .validate_tool_names(tools, available_tools)
  }

  # Check if enough tools remain after selection/validation for combinations
  if (is.null(selected_tool_names) || length(selected_tool_names) < 2) {
    warning("At least two valid tools must be selected to form combinations. Returning NULL.", call. = FALSE)
    return(NULL)
  }

  # --- 3. Prepare Data for Selected Tools ---
  selected_predictions_list <- SumSingleTools_list$tools[selected_tool_names]
  n_seqs <- length(SumSingleTools_list$seqIDs)

  # Ensure all selected prediction vectors have the correct length
  valid_lengths <- sapply(selected_predictions_list, length) == n_seqs
  if (!all(valid_lengths)) {
    invalid_tools_len <- names(valid_lengths[!valid_lengths])
    warning(paste("Length mismatch for selected tools:", paste(invalid_tools_len, collapse=", "), ". Cannot proceed."), call. = FALSE)
    return(NULL)
  }

  # Combine selected predictions into a matrix
  predictions_matrix_selected <- do.call(cbind, selected_predictions_list)
  colnames(predictions_matrix_selected) <- selected_tool_names # Ensure colnames are correct

  # --- 4. Generate Combinations and Calculate Matches ---
  tool_combinations_results <- list()
  n_selected <- length(selected_tool_names)

  # Iterate through combination sizes (from 2 up to n_selected)
  for (k in 2:n_selected) {
    # Get all combinations of tool *indices* for the current size k
    # utils::combn is used here
    tool_indices_combinations <- utils::combn(1:n_selected, k, simplify = FALSE)

    for (idx_vector in tool_indices_combinations) {
      # Names of tools in the current specific combination
      current_combination_tool_names <- selected_tool_names[idx_vector]
      # String identifier for this combination (e.g., "ToolA+ToolB")
      combination_id_string <- paste(current_combination_tool_names, collapse = "+")

      # Subset the prediction matrix to include only tools in the current combination
      # drop=FALSE ensures it remains a matrix even if k=1 (though k starts at 2 here)
      sub_matrix_for_combination <- predictions_matrix_selected[, idx_vector, drop = FALSE]

      # A sequence matches if all tools in this specific combination predict 1
      # rowSums will sum predictions for each sequence across tools in sub_matrix_for_combination
      # This sum must equal k (the number of tools in the current combination)
      is_match_for_sequence <- rowSums(sub_matrix_for_combination) == k

      # Store the binary vector (0/1) of matches for this combination
      tool_combinations_results[[combination_id_string]] <- as.integer(is_match_for_sequence)
    }
  }

  # --- 5. Assemble Output List ---
  final_list <- list(
    seqIDs = SumSingleTools_list$seqIDs,
    isNC = SumSingleTools_list$isNC,
    type = SumSingleTools_list$type,
    selected_tools_predictions = selected_predictions_list,
    tool_combinations = tool_combinations_results
  )

  return(final_list)
}
