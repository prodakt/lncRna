# --- Main bestToolComb Function ---

#' Calculate Performance Statistics for Tool Combination Predictions
#'
#' Computes confusion matrix statistics for predictions made by combinations of
#' tools, using the output from `sumCombTools`.
#'
#' @param sumCombToolsList A list generated by `sumCombTools()`, containing
#'   `$isNC` (true labels) and `$toolCombinations` (list of prediction
#'   vectors for each combination).
#' @param combinationsToAnalyze An optional character vector specifying the names
#'   of the tool combinations (e.g., "ToolA+ToolB") to analyze. If `NULL`
#'   (default) and the session is interactive, the user will be prompted to
#'   select combinations. In a non-interactive session, `NULL` results in
#'   analyzing all available combinations.
#' @param digits The number of decimal places to round final statistics
#'   (default: 4).
#'
#' @return A data frame where rows are performance metrics and columns correspond
#'   to the analyzed tool combinations, rounded. Returns `NULL` on error or
#'   if no statistics can be calculated.
#' @keywords confusion matrix accuracy performance caret lncRNA validation
#'   combination
#' @export
#' @importFrom caret confusionMatrix
#' @examples
#' # Assume helper functions are loaded:
#' # validateInputList, calculateSingleToolStats, validateCombinationNames,
#' # and selectCombinationsInteractively
#'
#' if (requireNamespace("caret", quietly = TRUE) &&
#'     exists("validateInputList") && exists("calculateSingleToolStats") &&
#'     exists("validateCombinationNames") &&
#'     exists("selectCombinationsInteractively")) {
#'
#'   # --- Create Example Data (mimicking sumCombTools output) ---
#'   set.seed(202) # for reproducibility
#'   n_s <- 60
#'   exampleCombList <- list(
#'     seqIDs = paste0("S", 1:n_s),
#'     isNC = sample(c(0, 1), n_s, replace = TRUE, prob = c(0.6, 0.4)),
#'     type = sample(c("nc", "cds"), n_s, replace = TRUE),
#'     selected_tools_predictions = list(), # Not directly used here
#'     toolCombinations = list(
#'       `ToolA+ToolB` = sample(c(0,1), n_s, replace=TRUE, prob=c(0.7,0.3)),
#'       `ToolA+ToolC` = sample(c(0,1), n_s, replace=TRUE, prob=c(0.6,0.4)),
#'       `ToolB+ToolC` = sample(c(0,1), n_s, replace=TRUE, prob=c(0.5,0.5)),
#'       `ToolA+ToolB+ToolC` = sample(c(0,1), n_s, replace=TRUE, prob=c(0.8,0.2))
#'     )
#'   )
#'
#'   # --- Example 1: Non-interactive use (safe for vignettes/tests) ---
#'   # We explicitly provide the combinations to analyze.
#'   combsToTest <- c("ToolA+ToolB", "ToolA+ToolB+ToolC")
#'   perfSpecificCombs <- bestToolComb(
#'     sumCombToolsList = exampleCombList,
#'     combinationsToAnalyze = combsToTest
#'   )
#'   print("Performance for specific combinations:")
#'   print(perfSpecificCombs)
#'
#'   # --- Example 2: Demonstrating interactive use ---
#'   # This block will only run if the session is interactive.
#'   # It will NOT run during R CMD check or Bioconductor builds.
#'   if (interactive()) {
#'     message("Running in interactive mode. You will be prompted for selection.")
#'     # In this case, we call the function with combinationsToAnalyze = NULL
#'     # to trigger the interactive prompt.
#'     perfInteractive <- bestToolComb(sumCombToolsList = exampleCombList)
#'     print(perfInteractive)
#'   }
#' }
#'
bestToolComb <- function(sumCombToolsList, combinationsToAnalyze = NULL, digits = 4) {

  # --- 1. Input Validation ---
  if (!validateBestToolCombInput(sumCombToolsList)) {
    return(NULL)
  }

  availableCombinations <- names(sumCombToolsList$toolCombinations)
  referenceLabels <- sumCombToolsList$isNC

  if (is.null(availableCombinations) || length(availableCombinations) == 0) {
    warning("No tool combination names found in sumCombToolsList$toolCombinations.", call. = FALSE)
    return(NULL)
  }

  # --- 2. Combination Selection (with interactive fallback) ---
  if (is.null(combinationsToAnalyze)) {
    selectedCombinations <- selectCombinationsInteractively(availableCombinations)
  } else {
    selectedCombinations <- validateCombinationNames(combinationsToAnalyze, availableCombinations)
  }

  if (is.null(selectedCombinations) || length(selectedCombinations) == 0) {
    warning("No valid tool combinations selected or available for analysis. Returning NULL.", call. = FALSE)
    return(NULL)
  }

  # --- 3. Calculate Statistics ---
  resultsList <- list()
  refFactor <- factor(referenceLabels, levels = c("0", "1"))
  nSeqs <- length(refFactor)

  for (combName in selectedCombinations) {
    predictionVector <- sumCombToolsList$toolCombinations[[combName]]

    if (length(predictionVector) != nSeqs) {
      warning(
        paste0(
          "Length mismatch for '", combName, "'. Expected ", nSeqs,
          " but got ", length(predictionVector), ". Skipping."
        ),
        call. = FALSE
      )
      next
    }

    singleCombStatsVector <- calculateSingleToolStats(
      toolName = combName,
      predictions = predictionVector,
      referenceFactor = refFactor
    )
    if (!is.null(singleCombStatsVector)) {
      resultsList[[combName]] <- singleCombStatsVector
    }
  }

  # --- 4. Format Output ---
  if (length(resultsList) == 0) {
    warning("No statistics could be calculated for the selected combinations.", call. = FALSE)
    return(NULL)
  }

  allMetricNames <- unique(unlist(lapply(resultsList, names)))
  if (is.null(allMetricNames)) {
    warning("Could not determine metric names from results. Returning NULL.", call. = FALSE)
    return(NULL)
  }

  alignedResultsList <- lapply(resultsList, function(combStatsVector) {
    template <- rep(NA_real_, length(allMetricNames))
    names(template) <- allMetricNames
    commonMetrics <- intersect(names(combStatsVector), allMetricNames)
    if (length(commonMetrics) > 0) {
      template[commonMetrics] <- combStatsVector[commonMetrics]
    }
    template
  })

  finalResultsDf <- as.data.frame(do.call(cbind, alignedResultsList), check.names = FALSE)

  finalResultsDf <- as.data.frame(
    lapply(finalResultsDf, function(col) {
      if (is.numeric(col)) round(col, digits = digits) else col
    }),
    check.names = FALSE,
    row.names = allMetricNames
  )

  return(finalResultsDf)
}


# --- Helper Functions for bestToolComb ---

#' Interactively Select Tool Combinations (or select all if non-interactive)
#'
#' Prompts the user to select tool combinations. If the session is not
#' interactive, it defaults to selecting all available combinations.
#'
#' @param availableCombinations A character vector of available combination names.
#' @return A character vector of selected combination names, or NULL if fails.
#' @keywords internal
#'
selectCombinationsInteractively <- function(availableCombinations) {
  if (!interactive()) {
    return(availableCombinations)
  }

  # The interactive part will only run if interactive() is TRUE
  message("Available tool combinations:")
  combOptions <- c("All Combinations", availableCombinations)

  # Format choices for display
  choices_text <- paste0(seq_along(combOptions), ": ", combOptions)
  message(paste(choices_text, collapse = "\n"))

  prompt <- "Enter numbers for combinations to analyze (e.g., 1 for All, or 2,4), then press Enter: "
  userInput <- readline(prompt = prompt)
  userInput <- gsub("\\s+", "", userInput)

  if (userInput == "") {
    warning("No selection made. Returning NULL.", call. = FALSE)
    return(NULL)
  }

  selectedIndicesStr <- strsplit(userInput, ",")[[1]]
  # No need for suppressWarnings here if we handle NA properly
  selectedIndices <- as.numeric(selectedIndicesStr)
  selectedIndices <- selectedIndices[!is.na(selectedIndices)]

  if (length(selectedIndices) == 0) {
    warning("Invalid selection. Please enter numbers. Returning NULL.", call. = FALSE)
    return(NULL)
  }

  if (1 %in% selectedIndices) {
    return(availableCombinations)
  }

  validIndices <- selectedIndices[selectedIndices > 1 & selectedIndices <= length(combOptions)]
  if (length(validIndices) == 0) {
    warning("Selected numbers do not correspond to available combinations. Returning NULL.", call. = FALSE)
    return(NULL)
  }
  return(availableCombinations[validIndices - 1])
}

#' Validate Input for bestToolComb Function
#'
#' Checks if the input list is valid for the bestToolComb function.
#'
#' @param sumCombToolsList A list expected to be generated by `sumCombTools()`.
#' @return TRUE if validation passes, FALSE otherwise.
#' @keywords internal
#'
validateBestToolCombInput <- function(sumCombToolsList) {
  requiredElements <- c("isNC", "toolCombinations")
  if (!validateInputList(sumCombToolsList, requiredElements)) {
    return(FALSE)
  }
  if (!is.list(sumCombToolsList$toolCombinations) || length(sumCombToolsList$toolCombinations) == 0) {
    warning("Input list '$toolCombinations' must be a non-empty list.", call. = FALSE)
    return(FALSE)
  }
  if (length(unique(sumCombToolsList$isNC)) < 2) {
    warning("Reference labels ('isNC') must contain at least two classes.", call. = FALSE)
    return(FALSE)
  }
  if (!requireNamespace("caret", quietly = TRUE)) {
    warning("Package 'caret' is required. Please install it.", call. = FALSE)
    return(FALSE)
  }
  return(TRUE)
}

#' Validate Provided Tool Combination Names
#'
#' Checks if provided combination names exist in the list of available combinations.
#'
#' @param combsToValidate Character vector of combination names to check.
#' @param availableCombs Character vector of all available combination names.
#' @return Character vector of validated combination names.
#' @keywords internal
#'
validateCombinationNames <- function(combsToValidate, availableCombs) {
  invalidCombs <- setdiff(combsToValidate, availableCombs)
  if (length(invalidCombs) > 0) {
    warning(
      "The following combinations were not found and will be skipped: ",
      paste(invalidCombs, collapse = ", "),
      call. = FALSE
    )
  }
  validatedCombs <- intersect(combsToValidate, availableCombs)
  return(validatedCombs)
}
