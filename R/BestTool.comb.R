# --- Main BestTool.comb Function ---

#' Calculate Performance Statistics for Tool Combination Predictions
#'
#' Computes confusion matrix statistics for predictions made by combinations of tools,
#' using the output from `SumCombTools`.
#'
#' @param SumCombTools_list A list generated by `SumCombTools()`, containing
#'                          `$isNC` (true labels) and `$tool_combinations` (list of
#'                          prediction vectors for each combination).
#' @param combinations_to_analyze An optional character vector specifying the names
#'                                of the tool combinations (e.g., "ToolA+ToolB") to analyze.
#'                                If `NULL` (default), and session is interactive,
#'                                user is prompted. If non-interactive and `NULL`,
#'                                all available combinations are analyzed.
#' @param digits The number of decimal places to round final statistics (default: 4).
#'
#' @return A data frame where rows are performance metrics and columns correspond
#'         to the analyzed tool combinations, rounded. Returns `NULL` on error or
#'         if no statistics can be calculated.
#' @keywords confusion matrix accuracy performance caret lncRNA validation combination
#' @export
#' @importFrom caret confusionMatrix # For .calculate_single_tool_stats if it uses it directly
#' @examples
#' # Assume helper functions are loaded:
#' # .validate_input_list, .calculate_single_tool_stats
#' # and the new helpers: .validate_besttool_comb_input,
#' # .select_combinations_interactively, .validate_combination_names
#'
#' if (requireNamespace("caret", quietly = TRUE) &&
#'     exists(".validate_input_list") && exists(".calculate_single_tool_stats") &&
#'     exists(".select_combinations_interactively") && exists(".validate_combination_names")) {
#'
#'   # --- Create Example Data (mimicking SumCombTools output) ---
#'   set.seed(202) # for reproducibility
#'   n_s <- 60
#'   example_comb_list <- list(
#'     seqIDs = paste0("S", 1:n_s),
#'     isNC = sample(c(0, 1), n_s, replace = TRUE, prob = c(0.6, 0.4)),
#'     type = sample(c("nc", "cds"), n_s, replace = TRUE),
#'     selected_tools_predictions = list(), # Not directly used here
#'     tool_combinations = list(
#'       `ToolA+ToolB` = sample(c(0,1), n_s, replace=TRUE, prob=c(0.7,0.3)),
#'       `ToolA+ToolC` = sample(c(0,1), n_s, replace=TRUE, prob=c(0.6,0.4)),
#'       `ToolB+ToolC` = sample(c(0,1), n_s, replace=TRUE, prob=c(0.5,0.5)),
#'       `ToolA+ToolB+ToolC` = sample(c(0,1), n_s, replace=TRUE, prob=c(0.8,0.2))
#'     )
#'   )
#'
#'   # --- Example 1: Analyze specific combinations ---
#'   combs_to_test <- c("ToolA+ToolB", "ToolA+ToolB+ToolC")
#'   perf_specific_combs <- BestTool.comb(SumCombTools_list = example_comb_list,
#'                                        combinations_to_analyze = combs_to_test)
#'   print("Performance for specific combinations:")
#'   print(perf_specific_combs)
#'
#'   # --- Example 2: Simulate non-interactive (analyzes all) ---
#'   cat("\nSimulating non-interactive run (analyzes all combinations):\n")
#'   perf_all_combs <- BestTool.comb(SumCombTools_list = example_comb_list)
#'   print(perf_all_combs)
#'
#' } else {
#'   message("Please install 'caret' and ensure all helper functions are loaded for examples.")
#' }
#'
BestTool.comb <- function(SumCombTools_list, combinations_to_analyze = NULL, digits = 4) {

  # --- 1. Input Validation ---
  # This uses a new specific helper, which should internally use .validate_input_list
  if (!.validate_besttool_comb_input(SumCombTools_list)) {
    return(NULL)
  }

  available_combinations <- names(SumCombTools_list$tool_combinations)
  reference_labels <- SumCombTools_list$isNC

  if (is.null(available_combinations) || length(available_combinations) == 0) {
    warning("No tool combination names found in SumCombTools_list$tool_combinations.", call. = FALSE)
    return(NULL)
  }

  # --- 2. Combination Selection ---
  if (is.null(combinations_to_analyze)) {
    selected_combinations <- .select_combinations_interactively(available_combinations)
  } else {
    selected_combinations <- .validate_combination_names(combinations_to_analyze, available_combinations)
  }

  if (is.null(selected_combinations) || length(selected_combinations) == 0) {
    warning("No valid tool combinations selected or available for analysis. Returning NULL.", call. = FALSE)
    return(NULL)
  }

  # --- 3. Calculate Statistics ---
  results_list <- list()
  ref_factor <- factor(reference_labels, levels = c("0", "1"))
  n_seqs <- length(ref_factor)

  for (comb_name in selected_combinations) {
    prediction_vector <- SumCombTools_list$tool_combinations[[comb_name]]

    if(length(prediction_vector) != n_seqs){
      warning(paste("Length mismatch for prediction vector of combination '", comb_name, "'. Expected ", n_seqs,
                    " but got ", length(prediction_vector), ". Skipping."), call. = FALSE)
      next
    }

    # Use the existing .calculate_single_tool_stats helper
    # The 'tool_name' argument for the helper will be our 'comb_name'
    single_comb_stats_vector <- .calculate_single_tool_stats(tool_name = comb_name,
                                                             predictions = prediction_vector,
                                                             reference_factor = ref_factor)
    if (!is.null(single_comb_stats_vector)) {
      results_list[[comb_name]] <- single_comb_stats_vector
    }
  }

  # --- 4. Format Output ---
  if (length(results_list) == 0) {
    warning("No statistics could be calculated for the selected combinations.", call. = FALSE)
    return(NULL)
  }

  all_metric_names <- unique(unlist(lapply(results_list, names)))
  if (is.null(all_metric_names)) {
    warning("Could not determine metric names from results. Returning NULL.", call. = FALSE)
    return(NULL)
  }

  aligned_results_list <- lapply(results_list, function(comb_stats_vector) {
    template <- rep(NA_real_, length(all_metric_names))
    names(template) <- all_metric_names
    common_metrics <- intersect(names(comb_stats_vector), all_metric_names)
    if(length(common_metrics) > 0){
      template[common_metrics] <- comb_stats_vector[common_metrics]
    }
    data.frame(MetricValue = template, row.names = all_metric_names)
  })

  # Combine the aligned data frames
  final_results_df <- do.call(cbind, aligned_results_list)

  # Store the correct column names (these have '+' from names(aligned_results_list))
  correct_column_names <- names(aligned_results_list)

  # Apply rounding
  # The list returned by lapply will have names derived from final_results_df's columns.
  # If final_results_df's columns were already "ToolA.ToolB", these would persist.
  # So, we set them correctly *before* this step.
  colnames(final_results_df) <- correct_column_names

  final_results_df_rounded_list <- lapply(final_results_df, function(col) {
    if(is.numeric(col)) round(col, digits = digits) else col
  })
  # Convert list back to data.frame
  final_results_df <- as.data.frame(final_results_df_rounded_list, check.names = FALSE)

  # Re-apply the correct column names and row names
  # Using check.names = FALSE in as.data.frame helps, but re-assigning is safest.
  colnames(final_results_df) <- correct_column_names
  rownames(final_results_df) <- all_metric_names

  return(final_results_df)
}


# --- Helper Functions for BestTool.comb ---

#' Validate Input for BestTool.comb Function
#'
#' Checks if the input list is valid for the BestTool.comb function,
#' including presence of 'caret' and appropriate 'isNC' labels.
#'
#' @param SumCombTools_list A list expected to be generated by `SumCombTools()`.
#' @return TRUE if validation passes, FALSE otherwise (with warnings).
#' @keywords internal validation helper
#'
.validate_besttool_comb_input <- function(SumCombTools_list) {
  # Use generic helper for basic structure and required elements
  required_elements <- c("isNC", "tool_combinations")
  if (!.validate_input_list(SumCombTools_list, required_elements)) {
    return(FALSE) # Warnings issued by .validate_input_list
  }

  # Specific checks for BestTool.comb
  if (!is.list(SumCombTools_list$tool_combinations) || length(SumCombTools_list$tool_combinations) == 0) {
    warning("Input list element '$tool_combinations' must be a non-empty list.", call. = FALSE)
    return(FALSE)
  }
  if (length(unique(SumCombTools_list$isNC)) < 2) {
    warning("Reference labels ('isNC') do not contain both classes (0 and 1). Cannot calculate confusion matrix.", call. = FALSE)
    return(FALSE)
  }
  if (!requireNamespace("caret", quietly = TRUE)) {
    warning("Package 'caret' is required but not installed. Please install it.", call. = FALSE)
    return(FALSE)
  }
  return(TRUE)
}

#' Interactively Select Tool Combinations
#'
#' Prompts the user to select tool combinations from a list if the session is interactive.
#' "All Combinations" is presented as the first option.
#'
#' @param available_combinations A character vector of available combination names.
#' @return A character vector of selected combination names, or NULL if selection fails.
#' @keywords internal interactive helper selection
#'
.select_combinations_interactively <- function(available_combinations) {
  if (!interactive()) {
    warning("Non-interactive session. Cannot prompt for combination selection. Analyzing all available combinations.", call. = FALSE)
    return(available_combinations)
  }

  cat("Available tool combinations:\n")
  comb_options <- c("All Combinations", available_combinations)
  choice_indices <- seq_along(comb_options)
  print(paste(choice_indices, ": ", comb_options, sep = ""), quote = FALSE)

  prompt <- "Enter numbers for combinations to analyze (e.g., 1 for All, or 2,4), then press Enter: "
  user_input <- readline(prompt = prompt)
  user_input <- gsub("\\s+", "", user_input)

  if (user_input == "") {
    warning("No selection made.", call. = FALSE)
    return(NULL)
  }

  selected_indices_str <- strsplit(user_input, ",")[[1]]
  selected_indices <- suppressWarnings(as.numeric(selected_indices_str))
  selected_indices <- selected_indices[!is.na(selected_indices)]

  if (length(selected_indices) == 0) {
    warning("Invalid selection. Please enter numbers.", call. = FALSE)
    return(NULL)
  }

  if (1 %in% selected_indices) { # "All Combinations" selected
    return(available_combinations)
  } else {
    valid_indices <- selected_indices[selected_indices > 1 & selected_indices <= length(comb_options)]
    if (length(valid_indices) == 0) {
      warning("Selected numbers do not correspond to available combinations.", call. = FALSE)
      return(NULL)
    }
    return(available_combinations[valid_indices - 1]) # Adjust index
  }
}

#' Validate Provided Tool Combination Names
#'
#' Checks if provided combination names exist in the list of available combinations.
#'
#' @param combs_to_validate Character vector of combination names.
#' @param available_combs Character vector of all available combination names.
#' @return Character vector of validated combination names.
#' @keywords internal validation helper
#'
.validate_combination_names <- function(combs_to_validate, available_combs) {
  invalid_combs <- setdiff(combs_to_validate, available_combs)
  if (length(invalid_combs) > 0) {
    warning(paste("The following combinations were not found and will be skipped:",
                  paste(invalid_combs, collapse = ", ")), call. = FALSE)
  }
  validated_combs <- intersect(combs_to_validate, available_combs)
  return(validated_combs)
}
