#' Calculate and Filter Confusion Matrices for Tool Combinations
#'
#' This function calculates confusion matrices for various tool combinations based
#' on predictions from `evaluateToolCombinations`. It can also filter these
#' matrices based on pre-calculated performance metrics and a given threshold.
#'
#' @param combinationSummaryList A list generated by `evaluateToolCombinations()`,
#'   containing `$toolCombinations` (a list of 0/1 prediction vectors) and
#'   `$isNC` (the true class labels).
#' @param metricsData An optional data frame where rows are metric names and
#'   columns are tool combination names (typically the output of
#'   `BestToolCombination()`). If provided, `metricToExtract` is looked up
#'   here for threshold-based filtering and printing. Defaults to `NULL`.
#' @param printMetricThresholds Logical. If `TRUE`, prints the value of
#'   `metricToExtract` for each combination, indicating if it meets the
#'   `threshold`. Defaults to `FALSE`.
#' @param threshold A numeric value (0 to 1) used to evaluate `metricToExtract`.
#'   Defaults to 0.8.
#' @param returnOnlyHigh Logical. If `TRUE`, returns confusion matrices only for
#'   combinations meeting the `threshold`. Defaults to `FALSE`.
#' @param metricToExtract The performance metric to use for filtering and
#'   printing (e.g., "Accuracy", "Sensitivity"). Defaults to "Accuracy".
#'
#' @return A named list where each element represents a confusion matrix for a
#'   tool combination. Each element is itself a list containing:
#'   \item{table}{A 2x2 numeric matrix representing the confusion table.}
#'   \item{positive}{A character string indicating the positive class level ("1").}
#'   \item{metrics}{A named numeric vector of all calculated performance metrics.}
#'   The returned list is filtered if `returnOnlyHigh = TRUE`.
#' @export
#'
#' @examples
#' # --- 1. Create mock data mimicking the outputs of previous functions ---
#' set.seed(202)
#' n_seq <- 100
#' # a) Mock output from evaluateToolCombinations()
#' mockCombinationSummary <- list(
#'   isNC = sample(c(0, 1), n_seq, replace = TRUE),
#'   toolCombinations = list(
#'     `ToolA+ToolB` = sample(c(0,1), n_seq, replace=TRUE, prob=c(0.2,0.8)),
#'     `ToolA+ToolC` = sample(c(0,1), n_seq, replace=TRUE, prob=c(0.6,0.4)),
#'     `ToolB+ToolC` = sample(c(0,1), n_seq, replace=TRUE, prob=c(0.5,0.5))
#'   )
#' )
#' # b) Mock output from BestToolCombination()
#' mockMetricsData <- BestToolCombination(
#'   combinationSummaryList = mockCombinationSummary
#' )
#'
#' # --- 2. Run calculateCM in different modes ---
#' # Example 1: Calculate all CMs without filtering
#' all_cms <- calculateCM(combinationSummaryList = mockCombinationSummary)
#' print(names(all_cms))
#' # Inspect the structure of a single element
#' str(all_cms[[1]])
#'
#' # Example 2: Print and filter based on a Sensitivity threshold >= 0.5
#' filtered_cms <- calculateCM(
#'   combinationSummaryList = mockCombinationSummary,
#'   metricsData = mockMetricsData,
#'   printMetricThresholds = TRUE,
#'   returnOnlyHigh = TRUE,
#'   metricToExtract = "Sensitivity",
#'   threshold = 0.5
#' )
#' print("Filtered CMs (Sensitivity >= 0.5):")
#' print(names(filtered_cms))
#'
calculateCM <- function(combinationSummaryList, metricsData = NULL,
                        printMetricThresholds = FALSE, threshold = 0.8,
                        returnOnlyHigh = FALSE, metricToExtract = "Accuracy") {
    
    # --- Input Validation ---
    stopifnot(
        "'combinationSummaryList' must be a list with 'isNC' and 'toolCombinations'" =
            is.list(combinationSummaryList) && all(c("isNC", "toolCombinations") %in% names(combinationSummaryList)),
        "'metricsData' must be a data.frame or NULL" = is.null(metricsData) || is.data.frame(metricsData)
    )
    
    tool_combinations <- combinationSummaryList$toolCombinations
    if (length(tool_combinations) == 0) {
        warning("'$toolCombinations' is empty. Returning an empty list.", call. = FALSE)
        return(list())
    }
    
    reference_labels <- combinationSummaryList$isNC
    if (length(unique(reference_labels)) < 2) {
        warning("Reference labels ('isNC') must contain both classes (0 and 1).", call. = FALSE)
        return(list())
    }
    
    # --- Initialization ---
    all_cm_list <- list()
    high_metric_cm_list <- list()
    
    if (printMetricThresholds) {
        message("\n--- Confusion Matrix Calculation & Filtering ---\n")
    }
    
    # --- Loop through each combination ---
    for (combo_name in names(tool_combinations)) {
        predictions_vector <- tool_combinations[[combo_name]]
        
        # --- a) Create the lightweight CM object ---
        TP <- sum(predictions_vector == 1 & reference_labels == 1, na.rm = TRUE)
        TN <- sum(predictions_vector == 0 & reference_labels == 0, na.rm = TRUE)
        FP <- sum(predictions_vector == 1 & reference_labels == 0, na.rm = TRUE)
        FN <- sum(predictions_vector == 0 & reference_labels == 1, na.rm = TRUE)
        
        cm_table <- matrix(c(TN, FN, FP, TP), nrow = 2,
                           dimnames = list(Prediction = c("0", "1"),
                                           Reference = c("0", "1")))
        
        cm_metrics <- calculateMetrics(predictions = predictions_vector,
                                       reference = reference_labels)
        
        current_cm_object <- list(
            table = cm_table,
            positive = "1",
            metrics = cm_metrics
        )
        all_cm_list[[combo_name]] <- current_cm_object
        
        # --- b) Determine metric value for filtering/printing ---
        metric_value <- NA_real_
        if (!is.null(metricsData)) {
            if (combo_name %in% colnames(metricsData) &&
                metricToExtract %in% rownames(metricsData)) {
                metric_value <- metricsData[metricToExtract, combo_name]
            }
        }
        
        if (is.na(metric_value) && !is.null(cm_metrics)) {
            metric_value <- cm_metrics[metricToExtract]
        }
        
        # --- c) Print if requested ---
        if (printMetricThresholds) {
            val_str <- ifelse(is.na(metric_value), "NA", sprintf("%.4f", metric_value))
            msg <- paste0("Combination: '", combo_name, "' - ", metricToExtract,
                          ": ", val_str)
            if (!is.na(metric_value) && metric_value >= threshold) {
                msg <- paste0(msg, " - *** HIGH (>= ", threshold, ") ***")
            }
            message(msg, "\n")
        }
        
        # --- d) Store if it meets the threshold ---
        if (!is.na(metric_value) && metric_value >= threshold) {
            high_metric_cm_list[[combo_name]] <- current_cm_object
        }
    }
    
    if (printMetricThresholds) {
        message("--- End of Calculation ---\n")
    }
    
    # --- Return final list based on user choice ---
    if (returnOnlyHigh) {
        return(high_metric_cm_list)
    } else {
        return(all_cm_list)
    }
}