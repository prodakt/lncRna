#' Calculate Confusion Matrices and Optionally Use Pre-calculated Metrics
#'
#' This function calculates `confusionMatrix` objects for tool combination
#' predictions from the `sumCombToolsList`. It can optionally use a separate data
#' frame of pre-calculated metrics to filter or highlight results.
#'
#' @param sumCombToolsList list. A list generated by `sumCombTools()`,
#'   containing `$tool_combinations` and `$isNC`.
#' @param bestToolCombMetricsData data.frame (optional). A data frame of metrics,
#'   typically the output of `bestToolComb()`. If provided,
#'   `metricToExtract` will be looked up here for threshold decisions.
#'   Defaults to `NULL`.
#' @param positiveClass character. The class level to be considered the
#'   "positive" class. Defaults to "1".
#' @param printMetricThresholdMethods logical. If TRUE, prints performance metric
#'   values for each combination. Defaults to FALSE.
#' @param threshold numeric. A threshold (0 to 1) used to evaluate
#'   `metricToExtract`. Defaults to 0.8.
#' @param returnOnlyHighMethods logical. If TRUE, returns confusion matrices only
#'   for combinations meeting the `threshold`. Defaults to FALSE.
#' @param metricToExtract character. The performance metric to extract/evaluate
#'   (e.g., "Accuracy", "Sensitivity"). Defaults to "Accuracy".
#'
#' @return A named list of `confusionMatrix` objects. The list may be filtered
#'   based on the `threshold` if `returnOnlyHighMethods` is TRUE.
#'
#' @importFrom caret confusionMatrix
#' @export
#' @examples
#' # Assume core package functions are available
#' if (requireNamespace("caret", quietly = TRUE) &&
#'     exists("sumCombTools") && exists("bestToolComb")) {
#'
#'   # 1. Create example input list
#'   set.seed(101)
#'   nSeqEx <- 50
#'   exampleSstList <- list(
#'     seqIDs = paste0("Seq", seq_len(nSeqEx)),
#'     tools = list(
#'       ToolX = sample(c(0,1),nSeqEx,replace=TRUE,prob=c(0.5,0.5)),
#'       ToolY = sample(c(0,1),nSeqEx,replace=TRUE,prob=c(0.4,0.6)),
#'       ToolZ = sample(c(0,1),nSeqEx,replace=TRUE,prob=c(0.7,0.3))
#'     ),
#'     type = sample(c("nc","cds"),nSeqEx,replace=TRUE), isNC=NULL
#'   )
#'   exampleSstList$isNC <- ifelse(exampleSstList$type=="nc",1,0)
#'
#'   # 2. Generate SumCombTools list
#'   sumCombToolsListExample <- sumCombTools(
#'       sumSingleToolsList = exampleSstList,
#'       tools = c("ToolX", "ToolY", "ToolZ")
#'   )
#'
#'   # 3. Generate metrics data (simulating bestToolComb output)
#'   bestToolCombMetricsExample <- NULL
#'   if (!is.null(sumCombToolsListExample)) {
#'     bestToolCombMetricsExample <- bestToolComb(
#'       sumCombToolsList = sumCombToolsListExample
#'     )
#'
#'     # Example 1: Using sumCombToolsList only
#'     message("\nExample 1: Using sumCombToolsList only")
#'     cmList1 <- calculateCm(
#'       sumCombToolsList = sumCombToolsListExample,
#'       printMetricThresholdMethods = TRUE,
#'       metricToExtract = "Accuracy"
#'     )
#'
#'     # Example 2: Using both lists, filtering by Sensitivity >= 0.5
#'     message("\nExample 2: Using both lists, filtering by Sensitivity >= 0.5")
#'     cmList2 <- calculateCm(
#'       sumCombToolsList = sumCombToolsListExample,
#'       bestToolCombMetricsData = bestToolCombMetricsExample,
#'       returnOnlyHighMethods = TRUE,
#'       metricToExtract = "Sensitivity",
#'       threshold = 0.50,
#'       printMetricThresholdMethods = TRUE
#'     )
#'   } else {
#'     message("Example sumCombToolsListExample could not be generated.")
#'   }
#' } else {
#'   message("Please install 'caret' and ensure package functions are loaded.")
#' }
calculateCm <- function(sumCombToolsList,
                        printMetricThresholdMethods = FALSE,
                        threshold = 0.8,
                        returnOnlyHighMethods = FALSE,
                        metricToExtract = "Accuracy",
                        bestToolCombMetricsData = NULL,
                        positiveClass = "1") {

  if (!validateCalculateCmInput(
    sumCombToolsList, bestToolCombMetricsData, threshold,
    metricToExtract, positiveClass)) {
    return(list())
  }

  confusionMatrixList <- list()
  highMetricMatrixList <- list()

  combinationNames <- names(sumCombToolsList$tool_combinations)
  referenceLabels <- sumCombToolsList$isNC
  nSeqs <- length(referenceLabels)

  if (is.null(combinationNames) || length(combinationNames) == 0) {
    warning("No tool combinations found in sumCombToolsList$tool_combinations.", call. = FALSE)
    return(list())
  }

  if (printMetricThresholdMethods) {
    message("\n--- Confusion Matrix Calculation for Tool Combinations ---")
  }

  for (combinationName in combinationNames) {
    predictionsVector <- sumCombToolsList$tool_combinations[[combinationName]]

    if (length(predictionsVector) != nSeqs) {
      warning(paste0("Length mismatch for '", combinationName, "'. Expected ",
                     nSeqs, ", got ", length(predictionsVector), ". Skipping."),
              call. = FALSE)
      next
    }

    currentCm <- calculateSingleCm(
      predictions = predictionsVector,
      reference = referenceLabels,
      positiveClass = positiveClass,
      combinationName = combinationName
    )

    if (is.null(currentCm)) {
      next
    }

    confusionMatrixList[[combinationName]] <- currentCm
    metricValueForDecision <- NA_real_

    if (!is.null(bestToolCombMetricsData)) {
      if (combinationName %in% colnames(bestToolCombMetricsData) &&
          metricToExtract %in% rownames(bestToolCombMetricsData)) {
        metricValueForDecision <- bestToolCombMetricsData[metricToExtract, combinationName]
        if (!is.numeric(metricValueForDecision)) {
          metricValueForDecision <- NA_real_
        }
      } else {
        warning(paste0("Metric '", metricToExtract, "' for combination '",
                       combinationName, "' not found in provided data. ",
                       "Will extract from new CM."), call. = FALSE)
      }
    }

    if (is.na(metricValueForDecision)) {
      metricValueForDecision <- extractMetricValue(
        currentCm, metricToExtract, combinationName
      )
    }

    if (printMetricThresholdMethods) {
      processMetricAndPrint(
        combinationName, metricToExtract, metricValueForDecision,
        threshold
      )
    }

    if (!is.na(metricValueForDecision) && metricValueForDecision >= threshold) {
      highMetricMatrixList[[combinationName]] <- currentCm
    }
  }

  if (printMetricThresholdMethods) {
    message("--- End of Confusion Matrix Calculation ---")
  }

  if (returnOnlyHighMethods) {
    return(highMetricMatrixList)
  } else {
    return(confusionMatrixList)
  }
}

# --- Helper Functions for calculateCm ---

#' Validate Input Data for calculateCm
#' @noRd
validateCalculateCmInput <- function(sumCombToolsList, bestToolCombMetricsData, threshold, metricToExtract, positiveClass) {
  if (!is.list(sumCombToolsList) ||
      !all(c("tool_combinations", "isNC") %in% names(sumCombToolsList))) {
    stop("'sumCombToolsList' must be a list with 'tool_combinations' and 'isNC'.")
  }
  if (!is.list(sumCombToolsList$tool_combinations)) {
    warning("'$tool_combinations' must be a list.", call. = FALSE)
    return(FALSE)
  }
  if (length(sumCombToolsList$isNC) == 0) {
    warning("'$isNC' is empty.", call. = FALSE)
    return(FALSE)
  }
  if (length(unique(sumCombToolsList$isNC)) < 2) {
    warning("Reference labels ('isNC') must contain at least two unique classes.", call. = FALSE)
    return(FALSE)
  }
  if (!is.null(bestToolCombMetricsData) && !is.data.frame(bestToolCombMetricsData)) {
    warning("'bestToolCombMetricsData' must be a data frame or NULL.", call. = FALSE)
    return(FALSE)
  }
  if (!is.numeric(threshold) || threshold < 0 || threshold > 1) {
    stop("'threshold' must be a numeric value between 0 and 1.")
  }
  if (!is.character(metricToExtract) || length(metricToExtract) != 1) {
    stop("'metricToExtract' must be a single character string.")
  }
  if (!is.character(positiveClass) || length(positiveClass) != 1) {
    stop("'positiveClass' must be a single character string.")
  }
  if (!requireNamespace("caret", quietly = TRUE)) {
    warning("Package 'caret' is required. Please install it.", call. = FALSE)
    return(FALSE)
  }
  return(TRUE)
}

#' Calculate Single Confusion Matrix
#' @noRd
calculateSingleCm <- function(predictions, reference, positiveClass, combinationName) {
  fixedLevels <- c("0", "1")
  predictionsChar <- as.character(predictions)
  referenceChar <- as.character(reference)

  if (!positiveClass %in% unique(referenceChar)) {
    warning(paste0("Positive class '", positiveClass, "' not in reference for '",
                   combinationName, "'. Skipping CM calculation."), call. = FALSE)
    return(NULL)
  }
  if (!all(unique(c(predictionsChar, referenceChar)) %in% fixedLevels)) {
    warning(paste0("Data for '", combinationName,
                   "' contains values other than '0' or '1'."), call. = FALSE)
  }

  dataFactor <- factor(predictionsChar, levels = fixedLevels)
  referenceFactor <- factor(referenceChar, levels = fixedLevels)

  tryCatch({
    caret::confusionMatrix(data = dataFactor, reference = referenceFactor, positive = positiveClass)
  }, error = function(e) {
    warning(paste0("Error in confusionMatrix for '", combinationName, "': ",
                   e$message), call. = FALSE)
    return(NULL)
  })
}

#' Print Metric Information for a Combination
#' @noRd
processMetricAndPrint <- function(combinationName, metricToExtract, metricValue, threshold) {
  outputString <- paste0(
    "Combination: '", combinationName, "' - ", metricToExtract, ": ",
    if (is.na(metricValue)) "NA" else sprintf("%.4f", metricValue)
  )

  if (!is.na(metricValue) && metricValue > threshold) {
    outputString <- paste0(outputString, " -  *** HIGH ", toupper(metricToExtract),
                           " (>", threshold, ") ***")
  }
  message(outputString)
}

#' Extract Metric Value from a confusionMatrix Object
#' @noRd
extractMetricValue <- function(cmObj, metricName, combinationName) {
  if (metricName %in% names(cmObj$overall)) {
    metricValue <- cmObj$overall[[metricName]]
  } else if (metricName %in% names(cmObj$byClass)) {
    metricValue <- cmObj$byClass[[metricName]]
  } else {
    warning(paste0("Metric '", metricName, "' not found for '",
                   combinationName, "'. Available: ",
                   paste(c(names(cmObj$overall), names(cmObj$byClass)), collapse=", ")),
            call. = FALSE)
    return(NA_real_)
  }
  if (!is.numeric(metricValue)) return(NA_real_)
  return(metricValue)
}
