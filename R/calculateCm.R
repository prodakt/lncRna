#' Calculate Confusion Matrices and Optionally Use Pre-calculated Metrics
#'
#' This function calculates `confusionMatrix` objects for tool combination
#' predictions from a `sumCombTools` list. It can optionally use a separate data
#' frame of pre-calculated metrics to filter or highlight results.
#'
#' @param sumCombToolsList A list generated by `sumCombTools()`, containing
#'   `$toolCombinations` and `$isNC`.
#' @param bestToolCombMetricsData An optional data.frame of metrics, typically
#'   the output of `bestToolComb()`. If provided, `metricToExtract` is looked
#'   up here for threshold decisions.
#' @param positiveClass The class level to be considered "positive". Defaults
#'   to "1".
#' @param printMetricThresholdMethods If `TRUE`, prints performance metric
#'   values for each combination.
#' @param threshold A numeric value (0 to 1) used to evaluate `metricToExtract`.
#' @param returnOnlyHighMethods If `TRUE`, returns confusion matrices only for
#'   combinations meeting the `threshold`.
#' @param metricToExtract The performance metric to extract/evaluate. Defaults
#'   to "Accuracy".
#'
#' @return A named list of `confusionMatrix` objects.
#'
#' @export
#' @examples
#' # Assume core package functions are available
#' if (requireNamespace("caret", quietly = TRUE)) {
#'
#'   # 1. Create a minimal example input list (mimicking sumSingleTools output)
#'   set.seed(101)
#'   nSeqEx <- 50
#'   exampleSstList <- list(
#'     seqIDs = paste0("Seq", seq_len(nSeqEx)),
#'     tools = list(
#'       ToolX = sample(c(0,1),nSeqEx,replace=TRUE),
#'       ToolY = sample(c(0,1),nSeqEx,replace=TRUE),
#'       ToolZ = sample(c(0,1),nSeqEx,replace=TRUE)
#'     ),
#'     type = sample(c("nc","cds"),nSeqEx,replace=TRUE),
#'     isNC = NULL
#'   )
#'   exampleSstList$isNC <- ifelse(exampleSstList$type=="nc",1,0)
#'
#'   # 2. Generate a valid sumCombTools list
#'   sumCombToolsListExample <- sumCombTools(
#'       sumSingleToolsList = exampleSstList,
#'       tools = c("ToolX", "ToolY", "ToolZ")
#'   )
#'
#'   # 3. Generate a valid bestToolComb metrics data frame
#'   bestToolCombMetricsExample <- bestToolComb(
#'     sumCombToolsList = sumCombToolsListExample
#'   )
#'
#'   # Now, with valid inputs, we can run the examples for calculateCm
#'   if (!is.null(sumCombToolsListExample) && !is.null(bestToolCombMetricsExample)) {
#'     message("\nExample 1: Using sumCombToolsList only")
#'     cmList1 <- calculateCm(
#'       sumCombToolsList = sumCombToolsListExample,
#'       printMetricThresholdMethods = TRUE,
#'       metricToExtract = "Accuracy"
#'     )
#'
#'     message("\nExample 2: Using both lists, filtering by Sensitivity >= 0.5")
#'     cmList2 <- calculateCm(
#'       sumCombToolsList = sumCombToolsListExample,
#'       bestToolCombMetricsData = bestToolCombMetricsExample,
#'       returnOnlyHighMethods = TRUE,
#'       metricToExtract = "Sensitivity",
#'       threshold = 0.50,
#'       printMetricThresholdMethods = TRUE
#'     )
#'   }
#' }
calculateCm <- function(sumCombToolsList,
                        printMetricThresholdMethods = FALSE,
                        threshold = 0.8,
                        returnOnlyHighMethods = FALSE,
                        metricToExtract = "Accuracy",
                        bestToolCombMetricsData = NULL,
                        positiveClass = "1") {

  if (!validateCalculateCmInput(
    sumCombToolsList, bestToolCombMetricsData, threshold,
    metricToExtract, positiveClass)) {
    return(list())
  }

  confusionMatrixList <- list()
  highMetricMatrixList <- list()

  combinationNames <- names(sumCombToolsList$toolCombinations)
  referenceLabels <- sumCombToolsList$isNC
  nSeqs <- length(referenceLabels)

  if (is.null(combinationNames) || length(combinationNames) == 0) {
    warning("No tool combinations found in sumCombToolsList$toolCombinations.", call. = FALSE)
    return(list())
  }

  if (printMetricThresholdMethods) {
    message("\n--- Confusion Matrix Calculation for Tool Combinations ---")
  }

  for (combinationName in combinationNames) {
    predictionsVector <- sumCombToolsList$toolCombinations[[combinationName]]

    if (length(predictionsVector) != nSeqs) {
      warning(paste0("Length mismatch for '", combinationName, "'. Skipping."), call. = FALSE)
      next
    }

    currentCm <- calculateSingleCm(
      predictions = predictionsVector,
      reference = referenceLabels,
      positiveClass = positiveClass,
      combinationName = combinationName
    )
    if (is.null(currentCm)) next

    confusionMatrixList[[combinationName]] <- currentCm
    metricValueForDecision <- NA_real_

    if (!is.null(bestToolCombMetricsData)) {
      if (combinationName %in% colnames(bestToolCombMetricsData) &&
          metricToExtract %in% rownames(bestToolCombMetricsData)) {
        metricValueForDecision <- bestToolCombMetricsData[metricToExtract, combinationName]
        if (!is.numeric(metricValueForDecision)) {
          metricValueForDecision <- NA_real_
        }
      } else {
        warning(paste0("Metric '", metricToExtract, "' for '", combinationName,
                       "' not found in provided data. Extracting from new CM."), call. = FALSE)
      }
    }

    if (is.na(metricValueForDecision)) {
      metricValueForDecision <- extractMetricValue(currentCm, metricToExtract, combinationName)
    }

    if (printMetricThresholdMethods) {
      processMetricAndPrint(combinationName, metricToExtract, metricValueForDecision, threshold)
    }

    if (!is.na(metricValueForDecision) && metricValueForDecision >= threshold) {
      highMetricMatrixList[[combinationName]] <- currentCm
    }
  }

  if (printMetricThresholdMethods) {
    message("--- End of Confusion Matrix Calculation ---")
  }

  if (returnOnlyHighMethods) {
    return(highMetricMatrixList)
  } else {
    return(confusionMatrixList)
  }
}

# --- Helper Functions for calculateCm ---

#' Validate Input Data for calculateCm
#' @noRd
validateCalculateCmInput <- function(sumCombToolsList, bestToolCombMetricsData, threshold, metricToExtract, positiveClass) {
  if (!is.list(sumCombToolsList) || !all(c("toolCombinations", "isNC") %in% names(sumCombToolsList))) {
    stop("'sumCombToolsList' must be a list with 'toolCombinations' and 'isNC'.")
  }
  if (!is.list(sumCombToolsList$toolCombinations)) {
    warning("'$toolCombinations' must be a list.", call. = FALSE)
    return(FALSE)
  }
  if (length(sumCombToolsList$isNC) == 0) {
    warning("'$isNC' is empty.", call. = FALSE)
    return(FALSE)
  }
  if (length(unique(sumCombToolsList$isNC)) < 2) {
    warning("Reference labels ('isNC') must contain at least two unique classes.", call. = FALSE)
    return(FALSE)
  }
  if (!is.null(bestToolCombMetricsData) && !is.data.frame(bestToolCombMetricsData)) {
    warning("'bestToolCombMetricsData' must be a data frame or NULL.", call. = FALSE)
    return(FALSE)
  }
  if (!is.numeric(threshold) || threshold < 0 || threshold > 1) {
    stop("'threshold' must be a numeric value between 0 and 1.")
  }
  if (!is.character(metricToExtract) || length(metricToExtract) != 1) {
    stop("'metricToExtract' must be a single character string.")
  }
  if (!is.character(positiveClass) || length(positiveClass) != 1) {
    stop("'positiveClass' must be a single character string.")
  }
  if (!requireNamespace("caret", quietly = TRUE)) {
    warning("Package 'caret' is required. Please install it.", call. = FALSE)
    return(FALSE)
  }
  return(TRUE)
}

#' Calculate Single Confusion Matrix
#' @noRd
calculateSingleCm <- function(predictions, reference, positiveClass, combinationName) {
  fixedLevels <- c("0", "1")
  predictionsChar <- as.character(predictions)
  referenceChar <- as.character(reference)

  if (!positiveClass %in% unique(referenceChar)) {
    warning(paste0("Positive class '", positiveClass, "' not in reference for '",
                   combinationName, "'. Skipping CM calculation."), call. = FALSE)
    return(NULL)
  }
  if (!all(unique(c(predictionsChar, referenceChar)) %in% fixedLevels)) {
    warning(paste0("Data for '", combinationName,
                   "' contains values other than '0' or '1'."), call. = FALSE)
  }

  dataFactor <- factor(predictionsChar, levels = fixedLevels)
  referenceFactor <- factor(referenceChar, levels = fixedLevels)

  tryCatch({
    caret::confusionMatrix(data = dataFactor, reference = referenceFactor, positive = positiveClass)
  }, error = function(e) {
    warning(paste0("Error in confusionMatrix for '", combinationName, "': ",
                   e$message), call. = FALSE)
    return(NULL)
  })
}

#' Print Metric Information for a Combination
#' @noRd
processMetricAndPrint <- function(combinationName, metricToExtract, metricValue, threshold) {
  outputString <- paste0(
    "Combination: '", combinationName, "' - ", metricToExtract, ": ",
    if (is.na(metricValue)) "NA" else sprintf("%.4f", metricValue)
  )

  if (!is.na(metricValue) && metricValue > threshold) {
    outputString <- paste0(outputString, " -  *** HIGH ", toupper(metricToExtract),
                           " (>", threshold, ") ***")
  }
  message(outputString)
}

#' Extract Metric Value from a confusionMatrix Object
#' @noRd
extractMetricValue <- function(cmObj, metricName, combinationName) {
  if (metricName %in% names(cmObj$overall)) {
    metricValue <- cmObj$overall[[metricName]]
  } else if (metricName %in% names(cmObj$byClass)) {
    metricValue <- cmObj$byClass[[metricName]]
  } else {
    warning(paste0("Metric '", metricName, "' not found for '",
                   combinationName, "'. Available: ",
                   paste(c(names(cmObj$overall), names(cmObj$byClass)), collapse=", ")),
            call. = FALSE)
    return(NA_real_)
  }
  if (!is.numeric(metricValue)) return(NA_real_)
  return(metricValue)
}
