#' Summarize Agreement Among Selected Coding Potential Tools
#'
#' Calculates indicators showing if a sequence was predicted as non-coding by
#' at least 'n' of the selected tools, for n from 1 to the number of selected tools.
#' Also includes the sum of positive predictions across the selected tools.
#' Uses the list output from `SumSingleTools` and allows interactive tool selection.
#'
#' @param SumSingleTools_list A list generated by `SumSingleTools()`, containing at least
#'                            `$seqIDs`, `$tools` (list of 0/1 prediction vectors),
#'                            `$isNC`, and `$type`.
#' @param tools An optional character vector specifying the names of the tools
#'              (from `names(SumSingleTools_list$tools)`) to analyze. If `NULL` (default),
#'              the user will be prompted to select tools interactively.
#'
#' @return A list containing:
#'         \item{seqIDs}{Original sequence identifiers from the input list.}
#'         \item{isNC}{Original numeric indicator (1=nc, 0=cds) from the input list.}
#'         \item{type}{Original type annotation ('nc', 'cds') from the input list.}
#'         \item{selected_tools_predictions}{A sublist containing only the prediction
#'                                           vectors for the tools selected for analysis.}
#'         \item{sums_selected_tools}{A numeric vector with the count of selected tools
#'                                    predicting non-coding (1) for each sequence.}
#'         \item{at_least_n}{A list where each element `atl{n}` is a numeric vector
#'                           (0/1) indicating if a sequence was predicted as non-coding
#'                           by at least `n` selected tools.}
#'         Returns `NULL` if input validation fails or no tools are selected.
#' @keywords summary agreement coding potential lncRNA validation consensus
#' @export
#' @examples
#' # --- Create Example Data (mimicking SumSingleTools output) ---
#' set.seed(456) # for reproducibility
#' n_seq_example <- 60
#' example_input_list <- list(
#'   seqIDs = paste0("ID", 1:n_seq_example),
#'   tools = list(
#'     ToolA = sample(c(0, 1), n_seq_example, replace = TRUE, prob = c(0.6, 0.4)),
#'     ToolB = sample(c(0, 1), n_seq_example, replace = TRUE, prob = c(0.4, 0.6)),
#'     ToolC = sample(c(0, 1), n_seq_example, replace = TRUE, prob = c(0.7, 0.3))
#'   ),
#'   type = sample(c("nc", "cds"), n_seq_example, replace = TRUE),
#'   isNC = NULL, # Will be derived
#'   sums = NULL   # Not strictly needed by SumAtLeast, but part of SumSingleTools output
#' )
#' example_input_list$isNC <- ifelse(example_input_list$type == "nc", 1, 0)
#' # example_input_list$sums <- rowSums(do.call(cbind, example_input_list$tools)) # Original sums
#'
#' # --- Example 1: Analyze specific tools ---
#' selected_tool_names_sal <- c("ToolA", "ToolB")
#' # Validate input first (normally done inside the function)
#' required_elems <- c("seqIDs", "tools", "isNC", "type")
#' if (.validate_input_list(example_input_list, required_elems)) {
#'   results_specific <- SumAtLeast(SumSingleTools_list = example_input_list,
#'                                  tools = selected_tool_names_sal)
#'   if (!is.null(results_specific)) {
#'     print("Results for ToolA and ToolB:")
#'     print("Sums based on selected tools (ToolA, ToolB):")
#'     print(head(results_specific$sums_selected_tools))
#'     print("At least 1 tool:")
#'     print(head(results_specific$at_least_n$atl1))
#'     print("At least 2 tools:")
#'     print(head(results_specific$at_least_n$atl2))
#'     print("Names of selected tools predictions:")
#'     print(names(results_specific$selected_tools_predictions))
#'   }
#' }
#'
#' # --- Example 2: Simulate non-interactive selection (selects first tool) ---
#' cat("\nSimulating non-interactive run (will select first tool):\n")
#' # Validate input first (normally done inside the function)
#' if (.validate_input_list(example_input_list, required_elems)) {
#'    results_noninteractive <- SumAtLeast(SumSingleTools_list = example_input_list,
#'                                         tools = NULL) # Pass NULL
#'    if (!is.null(results_noninteractive)) {
#'       print("Sums based on selected tools (ToolA):")
#'       print(head(results_noninteractive$sums_selected_tools))
#'       print("At least 1 tool:")
#'       print(head(results_noninteractive$at_least_n$atl1))
#'       print("Names of selected tools predictions:")
#'       print(names(results_noninteractive$selected_tools_predictions))
#'    }
#' }
#'
SumAtLeast <- function(SumSingleTools_list, tools = NULL) {

  # --- 1. Input Validation ---
  # Define required elements for this function
  required_elements <- c("seqIDs", "tools", "isNC", "type")
  # Use the generic validation helper
  if (!.validate_input_list(SumSingleTools_list, required_elements)) {
    # Warnings are issued by the helper function
    return(NULL)
  }

  available_tools <- names(SumSingleTools_list$tools)
  # The helper already checked that tools is a list and has names if required
  # But double-check names again in case validation logic changes
  if (is.null(available_tools) && length(SumSingleTools_list$tools) > 0) {
    warning("Tool names are missing from SumSingleTools_list$tools.", call. = FALSE)
    return(NULL) # Need names for selection
  }


  # --- 2. Tool Selection (using helpers) ---
  if (is.null(tools)) {
    selected_tools <- .select_tools_interactively(available_tools)
  } else {
    selected_tools <- .validate_tool_names(tools, available_tools)
  }

  # Check if any tools remain after selection/validation
  if (is.null(selected_tools) || length(selected_tools) == 0) {
    warning("No valid tools selected or available for analysis. Returning NULL.", call. = FALSE)
    return(NULL)
  }

  # --- 3. Core Calculation ---
  # Extract predictions only for selected tools
  selected_predictions_list <- SumSingleTools_list$tools[selected_tools]

  # Ensure all selected prediction vectors have the correct length
  n_seqs <- length(SumSingleTools_list$seqIDs) # Get sequence count again
  valid_lengths <- sapply(selected_predictions_list, length) == n_seqs
  if (!all(valid_lengths)) {
    # This check might be redundant if .validate_input_list checks first tool length,
    # but good to have for specifically selected tools.
    invalid_tools_len <- names(valid_lengths[!valid_lengths])
    warning(paste("Length mismatch for selected tools:", paste(invalid_tools_len, collapse=", "), ". Cannot proceed."), call. = FALSE)
    return(NULL)
  }

  # Combine selected predictions into a matrix
  # Handle the case where only one tool is selected (cbind needs >1 column)
  if (length(selected_predictions_list) > 1) {
    predictions_matrix <- do.call(cbind, selected_predictions_list)
  } else if (length(selected_predictions_list) == 1) {
    # If only one tool, it's already a vector (or becomes a matrix with 1 col)
    predictions_matrix <- as.matrix(selected_predictions_list[[1]])
    colnames(predictions_matrix) <- names(selected_predictions_list) # Keep name
  } else {
    # This case should be caught earlier by the selected_tools check
    predictions_matrix <- matrix(numeric(0), nrow=n_seqs, ncol=0)
  }


  # Calculate row sums (number of selected tools predicting non-coding)
  # This is the value the user requested
  if (ncol(predictions_matrix) > 0) {
    sums_selected <- rowSums(predictions_matrix)
  } else {
    # If matrix has 0 columns (shouldn't happen here), sums are 0
    sums_selected <- numeric(n_seqs)
  }


  # Calculate "at least n" indicators
  at_least_n_results <- list()
  ntools_selected <- length(selected_tools) # Use count of selected tools
  if (ntools_selected > 0) {
    for (n in 1:ntools_selected) {
      at_least_n_results[[paste0('atl', n)]] <- ifelse(sums_selected >= n, 1, 0)
    }
  } # If 0 tools selected (should be caught earlier), at_least_n_results remains empty


  # --- 4. Assemble Output List ---
  final_list <- list(
    seqIDs = SumSingleTools_list$seqIDs,
    isNC = SumSingleTools_list$isNC,
    type = SumSingleTools_list$type,
    selected_tools_predictions = selected_predictions_list, # Predictions for used tools
    sums_selected_tools = sums_selected,                   # ADDED: Sums based on selected tools
    at_least_n = at_least_n_results                        # The calculated indicators
  )

  return(final_list)
}
