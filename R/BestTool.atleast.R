#' Calculate Performance Statistics for "At Least N Tools" Predictions
#'
#' Computes confusion matrix statistics (accuracy, precision, recall, etc.)
#' for each "at least n tools" prediction vector generated by `SumAtLeast`.
#' Requires the 'caret' package and helper functions.
#'
#' @param SumAtLeast_list A list generated by `SumAtLeast()`, containing at least
#'                        `$isNC` (numeric vector of true labels: 1=nc, 0=cds) and
#'                        `$at_least_n` (a list of 0/1 prediction vectors named `atl1`, `atl2`, ...).
#' @param digits The number of decimal places to round the final statistics to (default: 4).
#'
#' @return A data frame where rows are performance metrics (combined overall and by-class)
#'         and columns correspond to the "at least n" (`atl1`, `atl2`, ...) predictions.
#'         Returns `NULL` if validation fails or no statistics can be calculated.
#' @keywords confusion matrix accuracy performance caret lncRNA validation consensus statistics
#' @export
#' @examples
#' # Ensure 'caret' and necessary helper functions are available
#' # Example assumes .validate_input_list and .calculate_single_tool_stats exist
#'
#' if (requireNamespace("caret", quietly = TRUE) &&
#'     exists(".validate_input_list") && exists(".calculate_single_tool_stats")) {
#'
#'   # --- Create Example Data (mimicking SumAtLeast output) ---
#'   set.seed(789) # for reproducibility
#'   n_seq_example <- 75
#'   example_atleast_list <- list(
#'     seqIDs = paste0("Seq", 1:n_seq_example),
#'     isNC = sample(c(0, 1), n_seq_example, replace = TRUE, prob = c(0.55, 0.45)),
#'     type = ifelse(sample(c(0, 1), n_seq_example, replace = TRUE) == 1, "nc", "cds"), # Example type
#'     selected_tools_predictions = list( # Example, not directly used by BestTool.atleast
#'        ToolX = sample(c(0,1), n_seq_example, replace=TRUE),
#'        ToolY = sample(c(0,1), n_seq_example, replace=TRUE)
#'     ),
#'     sums_selected_tools = sample(0:2, n_seq_example, replace=TRUE), # Example sums
#'     at_least_n = list(
#'       atl1 = ifelse(sample(0:2, n_seq_example, replace=TRUE) >= 1, 1, 0),
#'       atl2 = ifelse(sample(0:2, n_seq_example, replace=TRUE) >= 2, 1, 0)
#'       # atl3 = rep(0, n_seq_example) # Example that might cause issues if not handled
#'     )
#'   )
#'
#'   # --- Run BestTool.atleast ---
#'   performance_atleast <- BestTool.atleast(SumAtLeast_list = example_atleast_list)
#'
#'   print("Performance for 'at least n' predictions:")
#'   print(performance_atleast)
#'
#' } else {
#'   message("Please install 'caret' and ensure helper functions are loaded to run examples.")
#' }
#'
BestTool.atleast <- function(SumAtLeast_list, digits = 4) {

  # --- 1. Input Validation ---
  # Define required elements specifically for this function
  required_elements <- c("isNC", "at_least_n")
  # Use the generic validation helper for basic checks
  if (!.validate_input_list(SumAtLeast_list, required_elements)) {
    # Warnings issued by the helper
    return(NULL)
  }
  # Specific checks for this function
  if (!is.list(SumAtLeast_list$at_least_n) || length(SumAtLeast_list$at_least_n) == 0) {
    warning("Input list element '$at_least_n' must be a non-empty list.", call. = FALSE)
    return(NULL)
  }
  if (length(unique(SumAtLeast_list$isNC)) < 2) {
    warning("Reference labels ('isNC') do not contain both classes (0 and 1). Cannot calculate confusion matrix.", call. = FALSE)
    return(NULL)
  }
  # Check for caret package (can be moved to a dedicated helper if preferred)
  if (!requireNamespace("caret", quietly = TRUE)) {
    warning("Package 'caret' is required but not installed. Please install it.", call. = FALSE)
    return(NULL)
  }


  # --- 2. Calculate Statistics for each 'atl{n}' vector ---
  results_list <- list() # To store results for each atl{n}
  reference_labels <- SumAtLeast_list$isNC
  at_least_n_predictions <- SumAtLeast_list$at_least_n

  # Prepare reference factor once
  ref_factor <- factor(reference_labels, levels = c("0", "1"))
  n_seqs <- length(ref_factor) # Get number of sequences from reference

  # Iterate through the list of "at least n" predictions
  for (atl_name in names(at_least_n_predictions)) {
    predictions_vector <- at_least_n_predictions[[atl_name]]

    # Validate length of the current prediction vector
    if(length(predictions_vector) != n_seqs){
      warning(paste("Length mismatch for prediction vector '", atl_name, "'. Expected ", n_seqs,
                    " but got ", length(predictions_vector), ". Skipping."), call. = FALSE)
      next # Skip to next iteration
    }

    # Use the helper to calculate stats, passing the name (e.g., "atl1")
    single_result_vector <- .calculate_single_tool_stats(tool_name = atl_name,
                                                         predictions = predictions_vector,
                                                         reference_factor = ref_factor)

    if (!is.null(single_result_vector)) {
      results_list[[atl_name]] <- single_result_vector # Store the named vector
    }
    # Warnings for failed calculations are handled within the helper
  }

  # --- 3. Format Output ---
  if (length(results_list) == 0) {
    warning("No statistics could be calculated for any 'at_least_n' predictions.", call. = FALSE)
    return(NULL)
  }

  # --- Ensure Consistent Rows before cbind ---
  # Find the union of all metric names across all 'atl{n}' results
  all_metric_names <- unique(unlist(lapply(results_list, names)))
  if (is.null(all_metric_names)) {
    warning("Could not determine metric names from results. Returning NULL.", call. = FALSE)
    return(NULL)
  }


  # Create a list of data frames, ensuring each has all metrics
  aligned_results_list <- lapply(results_list, function(atl_stats_vector) {
    # Create a template vector with NAs for all possible metrics
    template <- rep(NA_real_, length(all_metric_names))
    names(template) <- all_metric_names

    # Fill the template with the actual values from the atl{n}'s results
    common_metrics <- intersect(names(atl_stats_vector), all_metric_names)
    if(length(common_metrics) > 0){
      template[common_metrics] <- atl_stats_vector[common_metrics]
    }

    # Convert the full template vector to a single-column data frame
    data.frame(MetricValue = template, row.names = all_metric_names)
  })

  # Combine the aligned data frames into a single data frame
  final_results_df <- do.call(cbind, aligned_results_list)

  # Set column names explicitly to the 'atl{n}' names
  colnames(final_results_df) <- names(aligned_results_list)

  # Round the numeric values in the final data frame
  final_results_df <- as.data.frame(lapply(final_results_df, function(col) {
    if(is.numeric(col)) round(col, digits = digits) else col
  }))
  # Ensure row names are preserved after lapply
  rownames(final_results_df) <- all_metric_names


  return(final_results_df)
}
