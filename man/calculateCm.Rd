% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CalculateCM.R
\name{calculateCM}
\alias{calculateCM}
\title{Calculate and Filter Confusion Matrices for Tool Combinations}
\usage{
calculateCM(
  combinationSummaryList,
  metricsData = NULL,
  printMetricThresholds = FALSE,
  threshold = 0.8,
  returnOnlyHigh = FALSE,
  metricToExtract = "Accuracy"
)
}
\arguments{
\item{combinationSummaryList}{A list generated by \code{evaluateToolCombinations()},
containing \verb{$toolCombinations} (a list of 0/1 prediction vectors) and
\verb{$isNC} (the true class labels).}

\item{metricsData}{An optional data frame where rows are metric names and
columns are tool combination names (typically the output of
\code{BestToolCombination()}). If provided, \code{metricToExtract} is looked up
here for threshold-based filtering and printing. Defaults to \code{NULL}.}

\item{printMetricThresholds}{Logical. If \code{TRUE}, prints the value of
\code{metricToExtract} for each combination, indicating if it meets the
\code{threshold}. Defaults to \code{FALSE}.}

\item{threshold}{A numeric value (0 to 1) used to evaluate \code{metricToExtract}.
Defaults to 0.8.}

\item{returnOnlyHigh}{Logical. If \code{TRUE}, returns confusion matrices only for
combinations meeting the \code{threshold}. Defaults to \code{FALSE}.}

\item{metricToExtract}{The performance metric to use for filtering and
printing (e.g., "Accuracy", "Sensitivity"). Defaults to "Accuracy".}
}
\value{
A named list where each element represents a confusion matrix for a
tool combination. Each element is itself a list containing:
\item{table}{A 2x2 numeric matrix representing the confusion table.}
\item{positive}{A character string indicating the positive class level ("1").}
\item{metrics}{A named numeric vector of all calculated performance metrics.}
The returned list is filtered if \code{returnOnlyHigh = TRUE}.
}
\description{
This function calculates confusion matrices for various tool combinations based
on predictions from \code{evaluateToolCombinations}. It can also filter these
matrices based on pre-calculated performance metrics and a given threshold.
}
\examples{
# --- 1. Create mock data mimicking the outputs of previous functions ---
set.seed(202)
n_seq <- 100
# a) Mock output from evaluateToolCombinations()
mockCombinationSummary <- list(
  isNC = sample(c(0, 1), n_seq, replace = TRUE),
  toolCombinations = list(
    `ToolA+ToolB` = sample(c(0,1), n_seq, replace=TRUE, prob=c(0.2,0.8)),
    `ToolA+ToolC` = sample(c(0,1), n_seq, replace=TRUE, prob=c(0.6,0.4)),
    `ToolB+ToolC` = sample(c(0,1), n_seq, replace=TRUE, prob=c(0.5,0.5))
  )
)
# b) Mock output from BestToolCombination()
mockMetricsData <- BestToolCombination(
  combinationSummaryList = mockCombinationSummary
)

# --- 2. Run calculateCM in different modes ---
# Example 1: Calculate all CMs without filtering
all_cms <- calculateCM(combinationSummaryList = mockCombinationSummary)
print(names(all_cms))
# Inspect the structure of a single element
str(all_cms[[1]])

# Example 2: Print and filter based on a Sensitivity threshold >= 0.5
filtered_cms <- calculateCM(
  combinationSummaryList = mockCombinationSummary,
  metricsData = mockMetricsData,
  printMetricThresholds = TRUE,
  returnOnlyHigh = TRUE,
  metricToExtract = "Sensitivity",
  threshold = 0.5
)
print("Filtered CMs (Sensitivity >= 0.5):")
print(names(filtered_cms))

}
