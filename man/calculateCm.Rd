% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calculateCm.R
\name{calculateCm}
\alias{calculateCm}
\title{Calculate Confusion Matrices and Optionally Use Pre-calculated Metrics}
\usage{
calculateCm(
  sumCombToolsList,
  printMetricThresholdMethods = FALSE,
  threshold = 0.8,
  returnOnlyHighMethods = FALSE,
  metricToExtract = "Accuracy",
  bestToolCombMetricsData = NULL,
  positiveClass = "1"
)
}
\arguments{
\item{sumCombToolsList}{list. A list generated by \code{sumCombTools()},
containing \verb{$tool_combinations} and \verb{$isNC}.}

\item{printMetricThresholdMethods}{logical. If TRUE, prints performance metric
values for each combination. Defaults to FALSE.}

\item{threshold}{numeric. A threshold (0 to 1) used to evaluate
\code{metricToExtract}. Defaults to 0.8.}

\item{returnOnlyHighMethods}{logical. If TRUE, returns confusion matrices only
for combinations meeting the \code{threshold}. Defaults to FALSE.}

\item{metricToExtract}{character. The performance metric to extract/evaluate
(e.g., "Accuracy", "Sensitivity"). Defaults to "Accuracy".}

\item{bestToolCombMetricsData}{data.frame (optional). A data frame of metrics,
typically the output of \code{bestToolComb()}. If provided,
\code{metricToExtract} will be looked up here for threshold decisions.
Defaults to \code{NULL}.}

\item{positiveClass}{character. The class level to be considered the
"positive" class. Defaults to "1".}
}
\value{
A named list of \code{confusionMatrix} objects. The list may be filtered
based on the \code{threshold} if \code{returnOnlyHighMethods} is TRUE.
}
\description{
This function calculates \code{confusionMatrix} objects for tool combination
predictions from the \code{sumCombToolsList}. It can optionally use a separate data
frame of pre-calculated metrics to filter or highlight results.
}
\examples{
# Assume core package functions are available
if (requireNamespace("caret", quietly = TRUE) &&
    exists("sumCombTools") && exists("bestToolComb")) {

  # 1. Create example input list
  set.seed(101)
  nSeqEx <- 50
  exampleSstList <- list(
    seqIDs = paste0("Seq", seq_len(nSeqEx)),
    tools = list(
      ToolX = sample(c(0,1),nSeqEx,replace=TRUE,prob=c(0.5,0.5)),
      ToolY = sample(c(0,1),nSeqEx,replace=TRUE,prob=c(0.4,0.6)),
      ToolZ = sample(c(0,1),nSeqEx,replace=TRUE,prob=c(0.7,0.3))
    ),
    type = sample(c("nc","cds"),nSeqEx,replace=TRUE), isNC=NULL
  )
  exampleSstList$isNC <- ifelse(exampleSstList$type=="nc",1,0)

  # 2. Generate SumCombTools list
  sumCombToolsListExample <- sumCombTools(
      sumSingleToolsList = exampleSstList,
      tools = c("ToolX", "ToolY", "ToolZ")
  )

  # 3. Generate metrics data (simulating bestToolComb output)
  bestToolCombMetricsExample <- NULL
  if (!is.null(sumCombToolsListExample)) {
    bestToolCombMetricsExample <- bestToolComb(
      sumCombToolsList = sumCombToolsListExample
    )

    # Example 1: Using sumCombToolsList only
    message("\nExample 1: Using sumCombToolsList only")
    cmList1 <- calculateCm(
      sumCombToolsList = sumCombToolsListExample,
      printMetricThresholdMethods = TRUE,
      metricToExtract = "Accuracy"
    )

    # Example 2: Using both lists, filtering by Sensitivity >= 0.5
    message("\nExample 2: Using both lists, filtering by Sensitivity >= 0.5")
    cmList2 <- calculateCm(
      sumCombToolsList = sumCombToolsListExample,
      bestToolCombMetricsData = bestToolCombMetricsExample,
      returnOnlyHighMethods = TRUE,
      metricToExtract = "Sensitivity",
      threshold = 0.50,
      printMetricThresholdMethods = TRUE
    )
  } else {
    message("Example sumCombToolsListExample could not be generated.")
  }
} else {
  message("Please install 'caret' and ensure package functions are loaded.")
}
}
